<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>仙人一张</title>
  
  
  <link href="http://yiiiqing.github.io/atom.xml" rel="self"/>
  
  <link href="http://yiiiqing.github.io/"/>
  <updated>2023-07-29T06:44:17.804Z</updated>
  <id>http://yiiiqing.github.io/</id>
  
  <author>
    <name>yiqing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用 CompletableFuture 解决接口大 payload 处理慢的问题</title>
    <link href="http://yiiiqing.github.io/2023/07/29/%E4%BD%BF%E7%94%A8-CompletableFuture-%E8%A7%A3%E5%86%B3%E6%8E%A5%E5%8F%A3%E5%A4%A7-payload-%E5%A4%84%E7%90%86%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yiiiqing.github.io/2023/07/29/%E4%BD%BF%E7%94%A8-CompletableFuture-%E8%A7%A3%E5%86%B3%E6%8E%A5%E5%8F%A3%E5%A4%A7-payload-%E5%A4%84%E7%90%86%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2023-07-29T06:41:47.000Z</published>
    <updated>2023-07-29T06:44:17.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-CompletableFuture-解决接口大-payload-处理慢的问题"><a href="#使用-CompletableFuture-解决接口大-payload-处理慢的问题" class="headerlink" title="使用 CompletableFuture 解决接口大 payload 处理慢的问题"></a>使用 CompletableFuture 解决接口大 payload 处理慢的问题</h1><h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>最近在项目中遇到一个接口需要减少响应时间. 这个接口的操作步骤有很多步.于是脑子就想起了流处理+异步, 尝试使用了 Java 的 CompletableFuture. 达到了预期的效果</p><p>背景是: 一个接口需要接收几万条数据的一个大 json 列表将所有符合条件的数据入库.</p><p><strong>至于 CompletableFuture 的用法本篇不再赘述.</strong></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>于是分一下几步:</p><ol><li>初始化返回 response 类(因为不管参数校验或者报错都要返回调用方)</li><li>将所有的数据进行参数校验</li><li>检查是否已经在库中(db 操作)</li><li>将不在库中的数据进行插入</li><li>将插入成功的数据对应的那条 response 类设置为成功</li></ol><p>有几个问题需要关注一下:</p><ol><li>如何在流处理中前面步骤失败的情况下跳过本步骤?</li><li>介于 CompletableFuture 会返回 Future 类. 采取怎样的方式去收集所有的流处理数据结果?</li></ol><p>解决方案:</p><ol><li><p>因为每一步其实都是 response 类在传递. response 类中添加一个 flag 来标记是否该条数据处理完成. 并且在 response 类中保存 request</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Response</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">boolean</span> completeFlag;</span><br><span class="line">  Request r;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteFlag</span><span class="params">()</span>&#123; <span class="keyword">return</span> completeFlag; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">setCompleteFlag</span><span class="params">(<span class="type">boolean</span> flag)</span>&#123; <span class="built_in">this</span>.completeFlag = flag; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">markComplete</span><span class="params">()</span>&#123;setCompleteFlag(<span class="literal">true</span>);&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRequest</span><span class="params">(Request r)</span>&#123;<span class="built_in">this</span>.r=r;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在循环处理每一条数据之前创建一个 list, 通过 list 去存所有的 future. 将 CompletableFuture 流处理结果存入 list 中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;CompletableFuture&lt;Response&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(size); <span class="comment">// size is batch size</span></span><br><span class="line"><span class="keyword">for</span>(Request r: requestList)&#123;</span><br><span class="line">  CompletableFuture&lt;Response&gt; future = CompletableFuture</span><br><span class="line">    .supplyAssync(()-&gt;r)</span><br><span class="line">    .thenApply(xxx) <span class="comment">// 这里是要传入一些Function, 所以需要自定义一些 Function 类</span></span><br><span class="line">    .thenApply(xxx)</span><br><span class="line">    .handle(xxx); <span class="comment">// 当然必须 handle 一下 error</span></span><br><span class="line">  list.add(future);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在最后等待获取结果</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allOf = CompletableFuture.allOf(list.toArray(<span class="keyword">new</span> <span class="title class_">CompletableFuture</span>[]));</span><br><span class="line">allOf.join();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用流处理的方式获取所有结果</span></span><br><span class="line">allOf</span><br><span class="line">  .thenApply(v -&gt; list.stream()</span><br><span class="line">             .map(CompletableFuture::join)</span><br><span class="line">             .collect(Collectors.toList()) <span class="comment">// 获取每个 list 成员的结果</span></span><br><span class="line">            )</span><br><span class="line">  .join().stream() <span class="comment">// stream of Response</span></span><br><span class="line">  .collect(Collectors.toList()) <span class="comment">// list of Response</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>以 25k 条 json object 数据为例:</p><ul><li>修改前处理总时间需要最快 90 秒</li><li>采用流处理后时间基本稳定在 20 - 30秒</li></ul><p>所以, 个人认为, <strong>Stream + CompletableFuture + 线程池</strong> 这三者对于这种高并发的时刻成效显著.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用-CompletableFuture-解决接口大-payload-处理慢的问题&quot;&gt;&lt;a href=&quot;#使用-CompletableFuture-解决接口大-payload-处理慢的问题&quot; class=&quot;headerlink&quot; title=&quot;使用 Complet</summary>
      
    
    
    
    <category term="Java" scheme="http://yiiiqing.github.io/categories/Java/"/>
    
    
    <category term="并发" scheme="http://yiiiqing.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
    <category term="Web" scheme="http://yiiiqing.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Spring-BeanFactory和FactoryBean的区别</title>
    <link href="http://yiiiqing.github.io/2023/04/13/Spring-BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yiiiqing.github.io/2023/04/13/Spring-BeanFactory%E5%92%8CFactoryBean%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-04-13T09:35:43.000Z</published>
    <updated>2023-05-25T08:00:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BeanFactory-和-FactoryBean"><a href="#BeanFactory-和-FactoryBean" class="headerlink" title="BeanFactory 和 FactoryBean"></a>BeanFactory 和 FactoryBean</h1><p>共同点: </p><ul><li>都是用来创建对象的</li></ul><p>不同点: </p><ul><li><p>FactoryBean类 实现接口FactoryBean</p><ul><li>实现<code>getObject()</code><ul><li>在这里可以自定义自己的返回对象的方法, 可以反射也可以 new</li><li>等于是一个定制化的 Factory</li></ul></li><li>实现<code>getObjectType()</code></li><li>实现<code>isSingleton()</code></li><li>FactoryBean 的调用地点: 获取 beanDefinition 的时候判断<code>isFactoryBean(beanName)</code> 就通过自己的方法来获取 bean</li></ul></li><li><p>BeanFactory 相当于流水线</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BeanFactory-和-FactoryBean&quot;&gt;&lt;a href=&quot;#BeanFactory-和-FactoryBean&quot; class=&quot;headerlink&quot; title=&quot;BeanFactory 和 FactoryBean&quot;&gt;&lt;/a&gt;BeanFactory</summary>
      
    
    
    
    <category term="Java" scheme="http://yiiiqing.github.io/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://yiiiqing.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Bean的生命周期</title>
    <link href="http://yiiiqing.github.io/2023/04/13/Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yiiiqing.github.io/2023/04/13/Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2023-04-13T09:22:34.000Z</published>
    <updated>2023-04-13T09:35:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring中-Bean-的生命周期"><a href="#Spring中-Bean-的生命周期" class="headerlink" title="Spring中 Bean 的生命周期"></a>Spring中 Bean 的生命周期</h1><ol><li>实例化 Bean 对象</li><li>设置对象属性</li><li>检查 Aware 相关接口并设置相关依赖</li><li>BeanPostProcessor 前置处理</li><li>检查是否implement 了 InitializingBean 以决定是否调用 afterPropertiesSet 方法</li><li>检查是否配置有自定义的 init-method</li><li>BeanPostProcessor 后置处理</li><li>注册必要的 Destruction 相关毁掉接口</li><li>使用 Bean</li><li>是否实现 DisposableBean 接口</li><li>是否配有自定义的 destroy 方法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring中-Bean-的生命周期&quot;&gt;&lt;a href=&quot;#Spring中-Bean-的生命周期&quot; class=&quot;headerlink&quot; title=&quot;Spring中 Bean 的生命周期&quot;&gt;&lt;/a&gt;Spring中 Bean 的生命周期&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="Java" scheme="http://yiiiqing.github.io/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://yiiiqing.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring容器的refresh方法</title>
    <link href="http://yiiiqing.github.io/2023/03/21/Spring%E5%AE%B9%E5%99%A8%E7%9A%84refresh%E6%96%B9%E6%B3%95/"/>
    <id>http://yiiiqing.github.io/2023/03/21/Spring%E5%AE%B9%E5%99%A8%E7%9A%84refresh%E6%96%B9%E6%B3%95/</id>
    <published>2023-03-21T08:40:55.000Z</published>
    <updated>2023-03-23T08:07:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring容器的refresh方法"><a href="#Spring容器的refresh方法" class="headerlink" title="Spring容器的refresh方法"></a>Spring容器的refresh方法</h1><h3 id="BeanFactory的创建以及准备"><a href="#BeanFactory的创建以及准备" class="headerlink" title="BeanFactory的创建以及准备"></a>BeanFactory的创建以及准备</h3><ol><li>prepareRefresh 刷新前的预处理<ol><li>initPropertySources() 初始化一些设置; 子类自定义个性化的属性设置方法;</li><li><code>getEnvironment().validateRequiredProperties();</code> 校验属性的合法等</li><li><code>this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);</code>保存容器中一些早期的事件;</li></ol></li><li><code>obtainFreshBeanFactory();</code> 获取BeanFactory<ol><li><code>refreshBeanFactory();</code><ol><li>创建了一个 <code>this.beanFactory = new DefaultListableBeanFactory();</code></li><li>设置id</li></ol></li><li><code>getBeanFactory()</code> 返回上一步的beanFactory</li><li>将创建的BeanFactory返回</li></ol></li><li><code>prepareBeanFactory(beanFactory);</code> BeanFactory的准备工作(BeanFactory进行一些设置)<ol><li>设置BeanFactory的类加载器, 支持表达式解析器</li><li>添加部分BeanPostProcessor [ApplicationContextAwareProcessor]</li><li>设置忽略的自动装配的接口 [EnvironmentAware,EmbeddedValueResolverAware…]</li><li>注册可以解析的自动装配 ,我们可以在任何组件中自动注入[BeanFactory,ResourceLoader,ApplicationEventPublisher,ApplicationContext]</li><li>添加BeanPostProcessor</li><li>添加编译时的AspectJ支持</li><li>给BeanFactory中注册一些能用的组件:<ol><li> <code>environment</code></li><li><code>systemProperties</code></li><li><code>systemEnvironment</code></li></ol></li></ol></li><li><code>postProcessBeanFactory(beanFactory);</code> BeanFactory准备工作完成后进行的后置处理工作<ol><li>子类通过重写这个方法在BeanFactory创建并准备完成后进一步的设置</li></ol></li></ol><h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>接着往下说</p><ol start="5"><li><p><code>invokeBeanFactoryPostProcessors(beanFactory);</code>执行BeanFactoryPostProcessors;</p><ol><li>BeanFactoryPostProcessors: BeanFactory的后置处理器, 在BeanFactory标准初始化之后进行的<ol><li>两个相关接口: <code>BeanFactoryPostProcessor</code>和<code>BeanDefinitionRegistryPostProcessor</code></li><li>执行<code>BeanFactoryPostProcessor</code>的方法<ol><li>先执行<code>BeanDefinitionRegistryPostProcessor</code><ol><li>获取所有的<code>BeanDefinitionRegistryPostProcessor</code></li><li>按照优先级排序: <code>PriorityOrdered</code> -&gt; <code>Ordered</code>指定顺序的 -&gt; 没有实行任何优先级或者顺序接口的</li></ol></li><li>再执行<code>BeanFactoryPostProcessor</code></li></ol></li></ol></li></ol></li><li><p>registerBeanPostProcessors(beanFactory);` 注册bean的后置处理器</p><p><strong>不同接口类型的BeanPostProcessor, 在Bean创建前后执行时机是不一样的</strong></p><p>DestructionAwareBeanPostProcessor</p><p>InstantiationAwareBeanPostProcessor</p><p>SmartInstantiationAwareBeanPostProcessor</p><p>MergedBeanDefinitionPostProcessor</p><ol><li><p>获取所有的BeanPostProcessor <code>beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);</code> </p><p>后置处理器都默认可以通过PriorityOrdered,Ordered接口来指定优先级</p></li><li><p>先注册PritorityOrdered优先级接口的BeanPostProcessor</p><p><code>beanFactory.addBeanPostProcessor(postProcessor)</code></p></li><li><p>再注册Ordered接口的</p></li><li><p>最后注册没有实现优先级接口的</p></li><li><p>最终注册MergedBeanDefinitionPostProcessor</p></li><li><p>这测一个ApplicationListenerDetector: 在Bean创建完成后检查是否是ApplicationListener, 如果是,<code>this.applicationContext.addApplicationListener</code></p></li></ol></li></ol><h3 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h3><ol start="7"><li>initMessageSource() 初始化MessageSource组件(做国际化,消息绑定,消息解析)<ol><li>获取BeanFactory</li><li>看容器中是否有id为messageSource的, 类型是MessageSource的组件<ol><li>如果有赋值给MessageSource, 如果没有, 自己创建一个DelegatingMessageSource</li></ol></li><li>把创建好的MessageSource注册在容器中; 以后获取国际化配置文件值的时候,可以自动注入MessageSource</li></ol></li></ol><h3 id="时间派发器"><a href="#时间派发器" class="headerlink" title="时间派发器"></a>时间派发器</h3><ol start="8"><li><code>initApplicationEventMulticaster</code> 初始化事件派发器<ol><li>获取BeanFactory</li><li>从BeanFactory中获取 applicationEventMulticaster (可以自行配置)</li><li>如果没有配置, 创建一个SimpleApplicationEventMulticaster</li><li>将创建的 applicationEventMulticaster 注入到容器 registerSingleton</li></ol></li></ol><ol start="9"><li><code>onRefresh</code> 留给子类<ol><li>子类可以重写这个方法, 在容器刷新时自定义逻辑</li></ol></li></ol><ol start="10"><li><code>registerListeners</code> 给容器中将所有项目里面的<code>ApplicationListener</code>注册进来<ol><li>从容器中拿到所有的<code>ApplicationListener</code>    </li><li>将每个监听器添加到事件派发器中</li><li>派发之前步骤产生的事件</li></ol></li></ol><h3 id="初始化Bean"><a href="#初始化Bean" class="headerlink" title="初始化Bean"></a>初始化Bean</h3><ol start="11"><li><p><code>finishBeanFactoryInitialization(beanFactory);</code> 初始化所有剩下的单实例bean</p><ol><li><p><code>beanFactory.preInstantiateSingletons();</code> 初始化</p><ol><li><p>获取容器中的所有Bean, 依次创建和初始化对象</p></li><li><p>获取Bean的定义信息 <code>RootBeanDefinition</code></p></li><li><p>Bean不是抽象的, 是单实例的, 不是LazyInit的. 进行创建</p><ol><li><p>判断是否是FactoryBean, 也就是是否实现了此接口-&gt;使用工厂方法创建</p></li><li><p>不是工厂Bean, 使用<code>getBean(beanName)</code>创建 (这里的方法跟直接调用ioc.getBean一样)</p><ol><li><p><code>getBean(beanName)</code></p></li><li><p><code>doGetBean(name, null, null, false);</code></p></li><li><p>先获取缓存中保存的单实例Bean, 如果能获取到, 说明这个Bean之前被创建过(所有创建过的Bean都会被缓存起来)</p><p><code>private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;&gt;(256);</code> 是从这里获取</p></li><li><p>缓存中获取不到, 开始Bean的创建流程</p></li><li><p>标记当前bean被创建<code>markBeanAsCreated</code></p></li><li><p>获取Bean的定义信息 <code>getMergedLocalBeanDefinition</code></p></li><li><p>获取当前Bean依赖的其他Bean <code>getDependsOn</code>;(这个也是配置在Bean<code>depends-on</code>属性上的) 如果有, 按照<code>getBean()</code>把依赖的Bean先创建出来</p></li><li><p>启动单实例Bean的创建流程</p><ol><li><p><code>createBean(beanName, mbd, args)</code></p></li><li><p><code>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</code> 让BeanPostProcessor先拦截返回代理对象</p><ol><li>先触发<code>applyBeanPostProcessorsBeforeInstantiation</code></li><li>如果有返回值<code>applyBeanPostProcessorsAfterInitialization</code></li></ol></li><li><p>如果前面的<code>resolveBeforeInstantiation</code>没有返回代理对象, 向下执行, 如果返回了代理对象, 结束创建.</p></li><li><p>调用 <code>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</code></p><ol><li><p>创建Bean实例</p><ol><li><code>obtainFromSupplier</code> 利用Supplier</li><li><code>instantiateUsingFactoryMethod</code> 利用工厂方法或构造器</li></ol></li><li><p><code>applyMergedBeanDefinitionPostProcessors</code> 调用MergedBeanDefinitionPostProcessor</p></li><li><p>为属性赋值<code>populateBean</code></p><ol><li><p>拿到<code>InstantiationAwareBeanPostProcessor</code>后置处理器; 执行<code>postProcessAfterInstantiation</code>方法</p></li><li><p>拿到<code>InstantiationAwareBeanPostProcessor</code>; 执行<code>postProcessProperties</code></p></li><li><p><strong>赋值</strong> 应用Bean属性的值; 为属性利用setter方法进行赋值:</p><p><code>applyPropertyValues(beanName, mbd, bw, pvs);</code></p></li></ol></li><li><p>初始化 <code>initializeBean</code></p><ol><li>执行Aware接口的方法<code>invokeAwareMethods</code>[如BeanNameAware\BeanClassLoaderAware\BeanFactoryAware]</li><li>执行后置处理器初始化之前的方法 <code>applyBeanPostProcessorsBeforeInitialization</code></li><li>执行初始化方法 <code>invokeInitMethods(beanName, wrappedBean, mbd);</code><ol><li>是否是<code>InitializingBean</code>接口实现, 执行接口规定的初始化</li><li>是否是自定义初始化方法, 有则执行<code>invokeCustomInitMethod</code></li></ol></li><li>执行后置处理器初始化之后的方法<code>applyBeanPostProcessorsAfterInitialization</code></li></ol></li><li><p>注册销毁方法</p></li></ol></li><li><p>将创建的Bean添加到缓存中<code>singletonObjects</code></p><p><strong>说白了IOC容器就是这种各样的Map; 很多的Map保存了单实例Bean, 各种环境信息;</strong></p><p>所有的Bean都利用<code>getBean</code>创建完成后, 检查所有的Bean是否是SmartInitializingSingleton接口的; 如果是, 就执行afterSingletonsInstantiated</p></li></ol></li></ol></li></ol></li></ol></li></ol></li><li><p><code>finishRefresh()</code> 完成BeanFactory的初始化创建工作 -&gt; IOC容器创建完成</p><ol><li><p><code>initLifycycleProcessor()</code> 获取生命周期有关的后置处理器 <code>LifecycleProcessor</code></p><p>加入到容器中</p><p>默认从容器中找, 如果没有 new 一个DefaultLifecycleProcessor</p><p>可以写一个</p></li><li><p>拿到处理器, 调用onRefresh方法</p></li><li><p>发布容器刷新完成时间<code>publishEvent</code></p></li></ol></li></ol><p>至此, 粗略的刷新过程就是这样</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Spring容器启动时会保存所有注册进来的Bean的定义信息<ol><li>xml</li><li>annotation: @Service @Component @Bean</li></ol></li><li>Spring容器会在合适的实际创建Bean<ol><li>用到这个bean的时候使用<code>getBean</code>方法创建, 创建好后保存在容器中</li><li>统一创建所有bean的时候``finishBeanFactoryInitialization`</li></ol></li><li><strong>后置处理器</strong><ol><li>每一个bean创建, 都会使用各种后置处理器进行处理, 来增强bean的功能<ul><li><code>AnnotationAwareAspectJAutoProxyCreator</code> AOP</li><li><code>AutowiredAnnotationBeanPostProcessor</code> 处理自动注入</li></ul></li></ol></li><li>事件驱动器<ol><li>ApplicationListener 监听</li><li>ApplicationEventMulticaster 事件派发器</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Spring容器的refresh方法&quot;&gt;&lt;a href=&quot;#Spring容器的refresh方法&quot; class=&quot;headerlink&quot; title=&quot;Spring容器的refresh方法&quot;&gt;&lt;/a&gt;Spring容器的refresh方法&lt;/h1&gt;&lt;h3 id=&quot;B</summary>
      
    
    
    
    <category term="Java" scheme="http://yiiiqing.github.io/categories/Java/"/>
    
    
    <category term="Spring" scheme="http://yiiiqing.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb知识点</title>
    <link href="http://yiiiqing.github.io/2023/01/12/JavaWeb%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://yiiiqing.github.io/2023/01/12/JavaWeb%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2023-01-12T07:05:09.000Z</published>
    <updated>2023-01-12T07:31:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaWeb知识点"><a href="#JavaWeb知识点" class="headerlink" title="JavaWeb知识点"></a>JavaWeb知识点</h1><h2 id="JavaWeb三大组件"><a href="#JavaWeb三大组件" class="headerlink" title="JavaWeb三大组件"></a>JavaWeb三大组件</h2><ul><li>Servlet: 处理请求</li><li>Filter: 过滤/拦截请求</li><li>Listener: 监听器</li></ul><p>除了listener的活化钝化和绑定解绑监听器需要javaBean实现,三大组件都需要注册</p><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><h3 id="过滤器使用步骤"><a href="#过滤器使用步骤" class="headerlink" title="过滤器使用步骤"></a>过滤器使用步骤</h3><ol><li><p>实现Filter接口</p></li><li><p>web.xml中配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">&lt;filter-name&gt;MyFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;filter-class&gt;com.yiqing.MyFilter&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;MyFilter&lt;/filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt;&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><p>url-parttern三种写法:</p><ol><li>精确匹配: /pics/hello.jsp</li><li>路径匹配: /pics/* 拦截pics路径下所有请求</li><li>后缀匹配: *.jsp 拦截所有.jsp结尾的请求</li></ol></li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">doFilter()&#123;</span><br><span class="line">  <span class="comment">// 放行请求</span></span><br><span class="line">  chain.doFilter(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>8个</p><ul><li>ServletRequest(2)</li><li>HttpSession(4)</li><li>ServletContext(2)</li></ul><p>2个的为生命周期监听器</p><p>HttpSession除了这两个还有额外的2个(活化钝化监听器, 绑定解绑监听器)</p><h3 id="掌握的监听器"><a href="#掌握的监听器" class="headerlink" title="掌握的监听器"></a>掌握的监听器</h3><h5 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a>ServletContextListener</h5><ul><li>生命周期监听器</li><li>监听ServletContext的创建和销毁(也就是监听服务器的启动和停止). 服务器启动为当前项目创建ServletContext对象, 服务器停止销毁创建的ServletContext对象;</li><li>ServletContext<ul><li>一个web项目对应一个ServletContext, 它代表当前项目的信息</li><li>可以作为<strong>最大的域对象</strong>在整个项目运行期间共享数据</li></ul></li></ul><h3 id="监听器使用步骤"><a href="#监听器使用步骤" class="headerlink" title="监听器使用步骤"></a>监听器使用步骤</h3><ol><li>实现对应的监听器接口</li><li>去web.xml中配置<ol><li>除了listener的活化钝化和绑定解绑监听器需要javaBean实现(HttpSessionActivationListener, HttpSessionBindingListener)</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JavaWeb知识点&quot;&gt;&lt;a href=&quot;#JavaWeb知识点&quot; class=&quot;headerlink&quot; title=&quot;JavaWeb知识点&quot;&gt;&lt;/a&gt;JavaWeb知识点&lt;/h1&gt;&lt;h2 id=&quot;JavaWeb三大组件&quot;&gt;&lt;a href=&quot;#JavaWeb三大组</summary>
      
    
    
    
    <category term="Java" scheme="http://yiiiqing.github.io/categories/Java/"/>
    
    
    <category term="WEB" scheme="http://yiiiqing.github.io/tags/WEB/"/>
    
  </entry>
  
  <entry>
    <title>kafka消息转本地队列多线程消费下发现的问题</title>
    <link href="http://yiiiqing.github.io/2022/07/15/kafka%E6%B6%88%E6%81%AF%E8%BD%AC%E6%9C%AC%E5%9C%B0%E9%98%9F%E5%88%97%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E8%B4%B9%E4%B8%8B%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://yiiiqing.github.io/2022/07/15/kafka%E6%B6%88%E6%81%AF%E8%BD%AC%E6%9C%AC%E5%9C%B0%E9%98%9F%E5%88%97%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%B6%88%E8%B4%B9%E4%B8%8B%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2022-07-15T05:00:05.000Z</published>
    <updated>2022-07-15T09:52:43.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kafka消息转本地队列多线程消费下发现的问题"><a href="#kafka消息转本地队列多线程消费下发现的问题" class="headerlink" title="kafka消息转本地队列多线程消费下发现的问题"></a>kafka消息转本地队列多线程消费下发现的问题</h1><p>这个问题来源于对于trace系统的改造。</p><blockquote><p> 之前的trace消费其实是没有问题的，但是整个trade结构被改造成了本地消息队列的形式，所以trace迁移新库的同时决定统一采用消息队列的形式来进行消费。</p></blockquote><p>trace本地队列主要由两部分组成：</p><ul><li>核心线程池master：负责开两个线程池，一个是dispatch，一个是monitor。是一个ScheduledThreadPool，时延由apollo配置控制。<ul><li>dispatch线程池：负责从kafka拉取信息放入本地队列中，循环拉取，在执行完一批后将会拉去新的一批，跳出条件为running为false。</li><li>monitor线程池：负责监控本地队列的占用情况</li></ul></li><li>worker：负责本地队列信息的消费，是一个ThreadPoolExecutor</li><li>本地队列：是一个blocking queue</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.consumer.subscribe(<span class="built_in">this</span>.getTopic());</span><br><span class="line"><span class="built_in">this</span>.master.scheduleWithFixedDelay(dispatch,</span><br><span class="line">                              KafkaConfig.getKafkaInitDelay(),</span><br><span class="line">                                   KafkaConfig.getKafkaThreadFixedDelay(),</span><br><span class="line">                                   MILLISECONDS);</span><br><span class="line"><span class="built_in">this</span>.master.scheduleWithFixedDelay(monitor,</span><br><span class="line">                                   KafkaConfig.getKafkaMonitorInitDelay(),</span><br><span class="line">                                   KafkaConfig.getKafkaMonitorThreadFixedDelay(),</span><br><span class="line">                                   MILLISECONDS);</span><br><span class="line"><span class="built_in">this</span>.running = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; threadNumber; i++) &#123;</span><br><span class="line">    <span class="type">ConsumeThread</span> <span class="variable">consumeThread</span> <span class="operator">=</span> getConsumeThread(i); <span class="comment">// 会返回一个Runnable</span></span><br><span class="line">    <span class="built_in">this</span>.worker.submit(consumeThread); <span class="comment">// 提交worker线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一（消费线程退出版）"><a href="#一（消费线程退出版）" class="headerlink" title="一（消费线程退出版）"></a><strong>一（消费线程退出版）</strong></h3><p>第一版的构成是不太一样的，思想是队列进来一个Runnable任务，就开启一个消费者线程进行消费，worker会创建一个新的Runnable匿名类消费这一条信息。<br>上线后发现功能无异常，但是会有巨大的创建销毁线程的开销，导致本地消费能力很低</p><h3 id="二（消费线程不退出版）"><a href="#二（消费线程不退出版）" class="headerlink" title="二（消费线程不退出版）"></a><strong>二（消费线程不退出版）</strong></h3><p>因为第一版的问题，为了加大本地消费能力，修改：<br>1修改消费线程为一个while循环，唯一出口为running参数为false<br>2在初始化的时候创建消费线程，交给worker去执行<br>这样的好处是：在队列中有无消息的情况下，这些消费线程都不会退出。节省了线程创建销毁的开销。<br>上线后发现消费能力从3k上涨到5k左右</p><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><p>第二版上线后发现有<strong>服务停止运行</strong>的情况。<br>刚开始排查的问题以为是服务问题，以为服务down掉了，检查之后发现状况为：<strong>dispatch停止运行</strong>，但是monitor却正常运行，日志发现本地队列为空，kafka topic lag持续增长。<br>这么说只有两个原因：</p><ol><li><p>kafka将consumer踢出去</p></li><li><p>dispatch线程池ScheduledThreadPool没有定时执行</p></li></ol><p>加了日志排除了2. 所以只能是1。再进行细化。<br><strong>kafka为什么要踢出我这个消费者？</strong></p><blockquote><p>稍微查了一下资料，发现==kafka在消费者长期未commit的情况下，将该消费者认为无法消费==，将进行rebalance。在之前代码的逻辑，为了满足业务需求，关闭了kafka自动提交。在trace放入本地队列失败的情况下(采用BlockingQueue的offer方法)，将会重新拉取同一个offset这一批数据，重新消费。但是由于仍然无法消费，所以在这个地方卡住了，kafka就将该消费者踢出去了。</p></blockquote><p>发现问题原因后有以下几个方法能解决（事后总结）：</p><ol><li>开启监控本地队列占用情况的线程，在本地队列将满的情况下，sleep dispatch线程。等待consumer消费本地队列。</li><li>原有的offer方法更改为put阻塞方法的执行。（本地队列是一个blockingQueue）</li><li>增加offer方法的等待时间</li><li>每次不再拉取一批数据放入队列, 而是一个逐一手动提交</li></ol><h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><p>没有采用上述2的原因是，put会严重降低效率，也测试了1方法，发现在业务上能实现，但是没有必要<br>尝试<strong>更改加长了offer时间，从50ms升高到500ms，发现报错基本消失</strong><br>目前为止应用运行一段时间被kafka踢出消费者组的情况已经解决了。<br>但是又发现了新的问题。</p><p><strong>消息有重复消费，因为每次拉取的数目是500条，如果有一条无法消费报错（如400），整段都无法commit。下次将会消费之前的offset。这样第1-399条将会重复消费。</strong><br>如果解决这个问题。需要大改。将消费者改为每次拉取一条的情况，手动指定offset提交，可以完全避免。但是由于成本太大，放弃这个方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放入队列的那段代码</span></span><br><span class="line">added = partition.get(index)</span><br><span class="line">                .offer(record.value(), KafkaConfig.getFastConsumerPartitionTimeout(), MILLISECONDS);</span><br></pre></td></tr></table></figure><h3 id="五-最终版"><a href="#五-最终版" class="headerlink" title="五 最终版"></a>五 最终版</h3><p>吸取了之前的经验。最终版做了以下优化：</p><ol><li>合理调节offer时间，使本地引用的消费能力与kafka本地队列的存放能力达到平衡。</li><li>在dispatch方法中加入错误跳出机制。<ol><li>之前dispatch是一直循环拉kafka数据，就算error，也会立即重新拉，这样在本地线程阻塞的时候，会在瞬间频繁出现error。导致kafka踢出consumer。(也就是在拥塞的时候还会放东西进去)</li><li>修改为: 一旦发现不能添加，直接跳出整个dispatch方法(之前是只要拉取的数据不为空一直在dispatch,没有起到定时的作用)。这样可以在ScheduledThreadPool下次开启dispatch之间(dispatch前文说过是定时的)不再拉取新的kafka数据。给与本地队列喘息时间被消费。</li><li>结合2通过设置dispatch线程池重启时间进行合理调节</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!records.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!running) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">added</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (ConsumerRecord&lt;String, T&gt; record : records) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> record.key().hashCode();</span><br><span class="line">      <span class="keyword">final</span> <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Math.abs(hashCode % threadNumber);</span><br><span class="line">      added = partition.get(index)</span><br><span class="line">          .offer(record.value(), KafkaConfig.getFastConsumerPartitionTimeout(), MILLISECONDS);</span><br><span class="line">      <span class="keyword">if</span> (!added) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (added) &#123;</span><br><span class="line">      consumer.commitAsync();</span><br><span class="line">      records = consumer.poll(KafkaConfig.getConsumerPollTimeout());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 无法加入本地队列, 消费能力不足, 等待消费.</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="六-最终版plus"><a href="#六-最终版plus" class="headerlink" title="六 最终版plus"></a>六 最终版plus</h3><p>没想到<br>还是运行了一段时间就down掉了。检查了jvm和容器状态推测，在down掉的时间cpu很高，基本在200左右。<br>所以是因为cpu使用率太高导致容器重启。cpu和线程直接挂钩，于是降低了数据库连接池个数(之前错误开了很大的连接池)，将cpu使用率由200降到了150。<br>但是核心原因是：<strong>为什么重启后consumer就不能消费了呢？</strong><br>**分析: **容器在重启前会调用shutdown方法。之前的shutdown方法只关闭了master线程池，并没有关闭consumer线程池。这导致容器关闭前consumer拉取的那一批数据无法被消费。kafka将流量压力又只给了一个容器（容器重启前的最后一个，基于重启前的rebalance结果）</p><p>查阅kafka官方文档:</p><blockquote><p>如果你没有在程序退出前很好关闭consumer，最明显的行为主是在下次启动程序消费数据时会发现consumer分配分区的过程可能非常慢，还有一个问题是Kafka不能立即知道consumer已经退出，如果同组在其他地方有其他消费者，rebalance要在心跳超时后才分触发</p></blockquote><p>在shutdown方法中增加了<code>consumer.close()</code></p><p>再结合上述的最终版, 最终这个服务达到了稳定.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;kafka消息转本地队列多线程消费下发现的问题&quot;&gt;&lt;a href=&quot;#kafka消息转本地队列多线程消费下发现的问题&quot; class=&quot;headerlink&quot; title=&quot;kafka消息转本地队列多线程消费下发现的问题&quot;&gt;&lt;/a&gt;kafka消息转本地队列多线程消费</summary>
      
    
    
    
    <category term="Kafka" scheme="http://yiiiqing.github.io/categories/Kafka/"/>
    
    
    <category term="Kafka" scheme="http://yiiiqing.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="http://yiiiqing.github.io/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yiiiqing.github.io/2021/11/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-10T03:12:22.000Z</published>
    <updated>2021-11-10T03:13:40.000Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://yiiiqing.github.io/2021/11/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yiiiqing.github.io/2021/11/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-11-09T11:32:10.000Z</published>
    <updated>2021-11-09T13:23:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式-单例模式"><a href="#设计模式-单例模式" class="headerlink" title="设计模式-单例模式"></a>设计模式-单例模式</h1><p>单例模式, 就是采取一定方法保证在整个软件系统中, 对某个类只能存在一个对象实例, 并且该类只提供一个取得其对象实例的方法(静态方法)</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>需要频繁进行创建和销毁的对象</li><li>创建对象耗时过多或耗费资源过多(重量级对象), 但又常用到的对象</li><li>工具类对象</li><li>频繁访问数据库或文件的对象(DataSource, session工厂)</li></ul><h2 id="八种方式"><a href="#八种方式" class="headerlink" title="八种方式"></a>八种方式</h2><h3 id="饿汉式-静态常量"><a href="#饿汉式-静态常量" class="headerlink" title="饿汉式(静态常量)"></a>饿汉式(静态常量)</h3><ul><li>构造器私有化</li><li>类的内部创建对象</li><li>对外暴露一个静态的公共方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有化, 外部不能new</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部创建对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>优缺点:</p><ol><li>优点: 写法比较简单, 类装载时候就完成实例化. 避免了线程同步问题</li><li>缺点: 在类装载的时候就完成实例化,没有达到Lazy Loading的效果. 但是, <strong>导致类装载的原因有很多种</strong>. 如果从始至终没有用到这个实例, 将会造成==内存浪费==</li></ol><h3 id="饿汉式-静态代码块"><a href="#饿汉式-静态代码块" class="headerlink" title="饿汉式(静态代码块)"></a>饿汉式(静态代码块)</h3><ul><li>与上面相似, 只不过将类实例化放在了静态代码块.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有化, 外部不能new</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在静态代码块中创建</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 内部创建对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点:</p><p>与上面类似, 通过jvm加载机制可以知道, <strong>static代码块和static常量的初始化在jvm编译器优化后, 其实是合并在一起的(等价), 执行先后顺序由代码的先后顺序评定</strong></p><p>注意: <strong>因为clinit方法是线程安全, 所以加载类的时候如果static加载的东西太多也会很慢</strong></p><p>==内存浪费==</p><blockquote><p>final的作用: 加final修饰的对象, 在连接-准备阶段就已经赋值, 没有final的在初始化阶段赋值</p></blockquote><h3 id="懒汉式-线程不安全"><a href="#懒汉式-线程不安全" class="headerlink" title="懒汉式(线程不安全)"></a>懒汉式(线程不安全)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个静态的共有方法, 只有使用到这个方法的时候,才会创建单例对象</span></span><br><span class="line">  <span class="comment">// 懒汉式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点:</p><ol><li>起到了Lazy Loading的效果, 但是只能在单线程下使用</li><li>多线程下, 一个线程进入了<code>if (instance == null)</code>语句块后, 还没执行后, 另一个线程也进入了这个语句块. 就会<strong>产生多个实例</strong>.</li></ol><p>==实际开发不要使用这种方式==</p><h3 id="懒汉式-线程安全-同步方法"><a href="#懒汉式-线程安全-同步方法" class="headerlink" title="懒汉式(线程安全, 同步方法)"></a>懒汉式(线程安全, 同步方法)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个静态的共有方法, 加入同步处理的代码, 解决线程安全问题</span></span><br><span class="line">  <span class="comment">// 懒汉式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点:</p><ol><li>解决了上述的线程不安全的问题</li><li><strong>效率低</strong>. 因为只有在第一次才会初始化instance, 其他的时间getInstance方法只是为了获取而已, 这样加入synchronized将会降低很多效率</li></ol><p>==实际开发中不推荐==</p><h3 id="懒汉式-线程不安全-同步代码块"><a href="#懒汉式-线程不安全-同步代码块" class="headerlink" title="懒汉式(线程不安全,同步代码块)"></a>懒汉式(线程不安全,同步代码块)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个静态的共有方法, 加入同步处理的代码, 解决线程安全问题</span></span><br><span class="line">  <span class="comment">// 懒汉式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span>  Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点:</p><ol><li><strong>不能起到线程同步的作用</strong>: 这样写也没有用! 和上面是一样的, 因为只要if判断结束进入if块中, 线程排队执行同步代码块, 第一个执行完了后, 第二个仍旧要执行! 连线程安全都做不到</li></ol><p>==实际开发中不能使用==</p><h3 id="双重检查"><a href="#双重检查" class="headerlink" title="双重检查"></a>双重检查</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 提供一个静态的共有方法, 加入双重检查锁</span></span><br><span class="line">  <span class="comment">// 懒汉式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点:</p><ol><li><strong>Double-Check概念其实是在多线程开发中经常用到的.</strong></li><li>实例化代码只执行了一次</li><li>线程安全; 延迟加载; 效率较高</li></ol><p>==开发中推荐使用==</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类的特点就是: </p><ul><li>当外部类装载的时候, 内部类是不会装载的.</li><li>当getInstance的时候只会装载一次, 还能保证线程安全</li></ul><blockquote><p>jvm在装载类的时候是线程安全的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写一个静态内部类, 该类中有一个静态属性 Singleton</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点:</p><ol><li>采用了类装载的机制来保证初始化实例时只有一个线程. <strong>jvm帮助我们保证了线程的安全性</strong>, 在类初始化时, 别的线程无法进入</li></ol><p>==推荐使用==</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayOK</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点:</p><ol><li>jdk1.5+后实现的枚举</li><li>避免多线程同步问题</li><li>防止反序列化重新创建新的对象</li><li>其他方法都可以通过反射破坏, 只有枚举不可以</li></ol><p>==强烈推荐==</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>推荐使用:</p><ul><li><input checked="" disabled="" type="checkbox"> 饿汉式(静态常量)</li><li><input checked="" disabled="" type="checkbox"> 饿汉式(静态代码块)</li><li><input disabled="" type="checkbox"> 懒汉式(线程不安全)</li><li><input disabled="" type="checkbox"> 懒汉式(线程安全,同步方法)</li><li><input disabled="" type="checkbox"> 懒汉式(线程不安全,同步代码块)</li><li><input checked="" disabled="" type="checkbox"> 双重检查</li><li><input checked="" disabled="" type="checkbox"> 静态内部类</li><li><input checked="" disabled="" type="checkbox"> 枚举</li></ul><p>所以懒汉式团灭 = =</p><p>jdk中单例模式的应用: Runtime类, 使用了饿汉式</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;设计模式-单例模式&quot;&gt;&lt;a href=&quot;#设计模式-单例模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式-单例模式&quot;&gt;&lt;/a&gt;设计模式-单例模式&lt;/h1&gt;&lt;p&gt;单例模式, 就是采取一定方法保证在整个软件系统中, 对某个类只能存在一个对象实例, </summary>
      
    
    
    
    <category term="设计模式" scheme="http://yiiiqing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://yiiiqing.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>http协议</title>
    <link href="http://yiiiqing.github.io/2021/11/05/http%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yiiiqing.github.io/2021/11/05/http%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-11-05T07:23:45.000Z</published>
    <updated>2021-11-08T07:56:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1><p>前一阵子跟着宋红康老师学了一遍 jvm, 收获颇深. 因为追求看视频的速度问题所以没有去做笔记. 后期回忆起来可能记忆犹如无根浮萍一般. 所以以后还是打算能记笔记就记笔记.</p><p>http tcp udp 什么的, 其实学过很多了遍. 就计算机网络来说, 本科学了一遍, 选修课刷 GPA 又选修了一遍, 研究生又学了一遍. 可以说是学了三遍了. 但是现在回想起来, 框架还在, 但是具体的细节比如 tcp 滑动窗口之类的还是忘记了,  还是要经常回忆复习的好.</p><h2 id="网络分层"><a href="#网络分层" class="headerlink" title="网络分层"></a>网络分层</h2><h3 id="复杂的网络"><a href="#复杂的网络" class="headerlink" title="复杂的网络"></a>复杂的网络</h3><p>由于网络环境来说, 会有数据丢包, 数据重复, 完整性校验, 信号衰减等等问题.</p><p>为了处理这种问题, 国际标准组织对于整个网络体系进行了分层, 同时也规定了每一层的交互规则. 为了解耦与可拓展性(这里其实类似于 Java 中的接口的作用)</p><h3 id="分层方法"><a href="#分层方法" class="headerlink" title="分层方法"></a>分层方法</h3><p>两种分层方法: OSI 和 TCP/IP</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/http%E5%8D%8F%E8%AE%AE/image-20211105154438898.png" alt="image-20211105154438898"></p><h3 id="一个-http-请求的分层解析流程"><a href="#一个-http-请求的分层解析流程" class="headerlink" title="一个 http 请求的分层解析流程"></a>一个 http 请求的分层解析流程</h3><ol><li>在浏览器输入域名回车</li><li>域名解析<ol><li>为什么解析? 网络中两端进行交互只认 ip 地址</li><li>首先查<strong>浏览器</strong>有没有这个 DNS 的缓存</li><li>如果没有去<strong>计算机本地 host</strong> 文件查看</li><li>如果没有, 发起 DNS 请求<ol><li>DNS 也是服务器, 也有自己的 IP 地址, 是配在操作系统的</li><li>DNS 是使用 UDP 协议的, 传输层会加一个 UDP 请求头<ol><li>DNS 有时候会用 TCP, 如果相应的内容超过 512 字节, 或者使用区域传送</li></ol></li><li>加一个网络层 IP 请求头</li><li>传送到数据链路层, 数据链路层加上自己的头, 并且加入下个机器的 MAC 地址(从网络层的 ARP 协议而来<a href="https://blog.csdn.net/ever_peng/article/details/80008638">https://blog.csdn.net/ever_peng/article/details/80008638</a>)</li><li>传送到路由器上面<ol><li>路由器是三层的(网络,数据链路,物理层), 不同于交换机(物理,数据链路)</li><li>路由器解析刚才收到的消息<ol><li>从物理层开始</li><li>数据链路层会查看 MAC 地址是否给与, 是的话交给网络层</li><li>网络层查看数据应该传送的下一个路由器是多少, 这里一般是传送到服务商的路由器</li></ol></li></ol></li><li>运营商解析地址并返回 DNS 信息</li><li>返回到路由器, 从网络层解析到物理层</li><li>返回到计算机<ol><li>从物理层开始</li><li>检查 IP 头(网络层)</li><li>检查UDP协议头(传输层)</li><li>DNS 拿到信息(应用层)</li></ol></li></ol></li></ol></li><li>根据 DNS 获取的信息, 发送 http 协议<ol><li>开始类似上面逐层加协议头</li><li>发送到路由器</li><li>路由器发送到运营商ISP找到目标服务器</li><li>到达目标服务器<ol><li>物理层</li><li>数据链路层解析</li><li>网络层解析</li><li>传输层解析, 这一层会解析端口, 比如 80</li><li>应用层解析, 交给对应端口的应用程序</li><li>应用程序构造一个 http 的响应报文回传</li></ol></li></ol></li><li>收到目标服务器的回传报文<ol><li>这里依然是逐层的</li></ol></li></ol><hr><p>==上面写的有点长, 其实脑海里在思考 http 协议交流过程的时候, 只需要建立两个塔状的模型, 一个是源计算机, 一个是目标计算机, 所有的交流都是从一方最高到对方最高. 牢记这一点即可==</p><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>HyperText Transfer Protocol</p><h3 id="五大特点"><a href="#五大特点" class="headerlink" title="五大特点"></a>五大特点</h3><ol><li>支持 c/s 模式</li><li>简单快速</li><li>灵活</li><li>无连接: 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。<ol><li>因为HTTP诞生之初，主要是为了应付容易很小的文本传输，所以即使这样也没多大的问题</li><li>为了解决TCP连接问题, HTTP1.1提出了持久连接</li><li>所以说这个无连接其实算是过去式</li></ol></li><li>无状态: HTTP协议无法根据之前的状态进行本次的请求处理<ol><li>为了解决无状态, 引入cookie技术</li></ol></li></ol><p>说白了五大特点简直是人硬凑的, 不过也是有时代因素吧, 现在看来只需要记住后面两个就可以了:</p><p>==无连接, 无状态==</p><p>注意: 无连接是应用层面上的无连接! 要从应用层去理解</p><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><ul><li>起始行(请求行)<ul><li>请求: GET /index.html HTTP/1.1<ul><li>构成: <strong>METHOD</strong>+空格+<strong>URI</strong>+空格+<strong>VERSION</strong>+换行</li></ul></li><li>返回: HTTP/1.1 200 OK<ul><li>构成: <strong>VERSION</strong>+空格+<strong>STATUS CODE</strong>+空格+<strong>REASON</strong>+换行</li></ul></li></ul></li><li>头部字段集合<ul><li>Connection: keep-alive</li><li>…</li></ul></li><li>空行</li><li>消息正文</li></ul><hr><p>http协议还有很多, 暂时先跳过</p><h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>Transmission Control Protocol</p><p>面向连接的, 可靠的, 基于字节流的传输层通信协议</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>基于连接的: 数据传输之前都要建立连接</li><li>全双工: 双向传输</li><li>字节流: 不限制数据大小, 打包成报文段, 保证有序接收, 重复报文自动丢弃<ul><li>因为网络,数据到达很可能<strong>乱序</strong>, 接收端需要<strong>重排序</strong></li><li>给到应用层肯定是排序后的</li></ul></li><li>流量缓冲: 解决双方处理能力的不匹配</li><li>可靠的传输服务: 保证可达, 丢包时通过数据<strong>重发机制</strong>实现可靠性</li><li><strong>拥塞控制</strong>: 防止网络出现恶心拥塞</li></ul><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>四元组: 源地址, 源端口, 目的地址, 目的端口</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/http%E5%8D%8F%E8%AE%AE/image-20211105181040504.png" alt="image-20211105181040504"></p><p>一个小的知识点: <strong>为什么ack是x+1呢?</strong></p><p>官方的回答是:</p><blockquote><p>The server responds to the client with a sequence number of zero, as this is its first packet in this TCP session, and a relative acknowledgement number of 1. The acknowledgement number is set to 1 to indicate the receipt of the client’s SYN flag in packet #1.</p><p>Notice that the acknowledgement number has been increased by 1 although no payload data has yet been sent by the client. This is because the presence of the SYN or FIN flag in a received packet triggers an increase of 1 in the sequence. (This does not interfere with the accounting of payload data, because packets with the SYN or FIN flag set do not carry a payload.)</p></blockquote><p>也就是由于SYN或者FIN标志位的存在,造成了sequence的增加. </p><ul><li>+1是针对SYN和FYN的，主要是在没有数据传输的情况下，告诉发送端我收到了你之前发的这俩标示（的其中一个）</li><li>这个+1是基于对方的seq来加的</li></ul><p>感谢这篇文章的参考:<a href="https://blog.csdn.net/oldfish_C/article/details/105150516">https://blog.csdn.net/oldfish_C/article/details/105150516</a></p><hr><ul><li>linux可以通过`netstat -来查看tcp连接的状态</li><li>可以通过<code>telnet [ip] [port]</code> 建立tcp连接</li></ul><hr><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p><strong>两端都可以关闭连接, 在此将主动关闭的称为client</strong></p><p>图中的M和N和上面图中x和y是一样的含义, 只是因为分开画的表示不一样.</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/http%E5%8D%8F%E8%AE%AE/image-20211108112734056.png" alt="image-20211108112734056"></p><ul><li>server在close_wait阶段仍然可以发数据, 发送结束后发送FIN</li><li>client time_wait阶段等待一个来回的时间(2MSL)==面试高频==<ul><li>防止滞留在网络中的报文, 对新建立的连接造成数据扰乱(确保close_wait阶段的内容被收到)</li><li>防止报文丢失(也就是图中最后一个ACK), 导致server重复发送FIN</li></ul></li></ul><hr><h3 id="字节流的协议"><a href="#字节流的协议" class="headerlink" title="字节流的协议"></a>字节流的协议</h3><ul><li>TCP把应用层的数据看成一连串的无结构的字节流; 数据将会被切割成小报文; TCP根据报文的序列号进行排序</li><li>TCP并不知道字节流的含义</li><li>TCP并不关心应用程序一次将多大的报文发送到TCP的缓存中, 而是根据对方给出的窗口和当前网络的拥堵程度来决定一个报文段应该包含多少字节</li><li>MSS: Max Segment Size. 默认 536byte 实际数据</li><li>报文没有收到ack消息的话将会重传</li></ul><hr><h3 id="数据可靠性传输"><a href="#数据可靠性传输" class="headerlink" title="数据可靠性传输"></a>数据可靠性传输</h3><h4 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h4><p>即发送一个分组就停止发送, 等待对方确认, 确认后再发送下一个分组</p><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><ol><li>ack报文丢失: 请求报文收到但是回复的ack报文丢失, 也会导致重传</li><li>请求报文丢失: 直接是请求报文丢失, 那么自然不会ack, 所以会超时重传</li></ol><h4 id="滑动窗口协议与累计确认-延时ack"><a href="#滑动窗口协议与累计确认-延时ack" class="headerlink" title="滑动窗口协议与累计确认(延时ack)"></a>滑动窗口协议与累计确认(延时ack)</h4><ul><li>因为停止等待和重传机制非常的效率低下, tcp通过这个协议解决信道效率低,增加吞吐量.</li><li>上面提到 ack 其实非常浪费时间, 那么如何破除停止等待协议? 使用滑动窗口协议. 允许发送方在停止并等待确认前发送多个数据分组. 由按序到达的最后一个分组发送确认. 发送确认即表明这个窗口全部收到, 那么窗口将会滑动到后面.<ul><li>12345全部收到, 窗口将会滑动到6;</li><li>如果12345只收到了1245, 发送的确认信息告诉对方3没有收到, 那么窗口将会滑动到3</li></ul></li><li>滑动窗口大小通过tcp三次握手和对端协商, 且受网络状况影响.</li></ul><hr><h2 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h2><p>HTTP天生”明文”, 整个传输过程透明. HTTPS就是为了安全而诞生的</p><p>HTTPS其实就是HTTP的基础上增加了一个安全层. 在HTTP和TCP之间使用SSL/TLS构成安全层.</p><ul><li>原本HTTP直接与TCP交互</li><li>使用安全层后, HTTP层与安全层交互, 安全层再与TCP交互</li></ul><h3 id="SSL-TLS"><a href="#SSL-TLS" class="headerlink" title="SSL/TLS"></a>SSL/TLS</h3><p>SSL: 安全套接层(Secure Sockets Layer)</p><p>TLS: 传输层安全(Transport Layer Security). 1999年IETF将SSL改名为TLS. 现已发展到1.3. 版本紧跟密码学研究.</p><h3 id="摘要算法"><a href="#摘要算法" class="headerlink" title="摘要算法"></a>摘要算法</h3><p>md5, sha1, sha2, sha256</p><p>摘要算法能把任意长度的数据”压缩”成固定长度, 并且独一无二. </p><p>所以通过<strong>将明文的信息的摘要和明文一起加密进行传输</strong>, 数据接收方解密, <strong>重新</strong>对数据进行<strong>摘要</strong>, 再<strong>比对</strong>就可以发现数据有没有被篡改. 保障了数据的完整性.</p><h3 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h3><ul><li>对称密钥加密算法<ul><li>编解码使用相同密钥</li><li>AES, RC4, ChaCha20</li><li>经典实现: xor异或<ul><li>将原文与密钥异或得到密文</li></ul></li></ul></li><li>非对称密钥加密算法<ul><li>一个叫公钥, 一个叫私钥. 公钥公开, 私钥保密. 发送方用公钥加密数据传输, 密文只能由私钥持有者(接收方)才可能解密.</li><li>需要大量数学运算, 比较慢.</li></ul></li></ul><hr><p>TLS里使用的混合加密方式, 即把对称加密和非对称加密结合起来, 两者互相取长补短.</p><ol><li>通信开始使用非对称算法解决<strong>密钥交换</strong>的问题. 对方服务器发送公钥(公钥数字证书).<ol><li>在连接之初client发送有一个加密套件列表进行</li><li>服务器在client支持的加密套件中选择一个加密套件返回公钥数字证书</li></ol></li><li>密钥交换之后, 使用<strong>对称加密来传输数据</strong></li></ol><p>这里有一个重点, 就是, 我是通过这种方式来保证传输安全了, 那万一对面根里其实就烂了(server就是fake)呢?</p><p>这样我们需要一个方法来确保公钥是正确的server发送的. 这里就出现了一个机构也就是<strong>CA机构</strong>.</p><p>所以其实上面发送的公钥是一个<strong>公钥数字证书</strong>, 是由CA机构颁发的. 证书包含CA信息, 公钥用户信息, 公钥, 权威机构的签名, 有效期等等.</p><p>那肯定我就又有疑问了. 那CA也烂了咋办?</p><p>所以其实CA证书是一个<strong>证书链</strong>, 逐层向上验证, 一直到最后有一个根证书来提供最后的保障. 这个不是走互联网的, 这个是操作系统写入的. 所以也就是说我们确保了最最根部的CA证书是正确的, 剩下的逐层验证即可.</p><hr><p>到此为止也算是把http和tcp还有https过了一遍了, 深度肯定还不够, 譬如tcp的拥塞控制还没有写. 这个我觉得需要另开一个篇章去写, 就不放到http协议这里了. </p><p>拥塞控制可以参考这篇文章: <a href="https://zhuanlan.zhihu.com/p/37379780">https://zhuanlan.zhihu.com/p/37379780</a></p><p>OK! 努力年薪百万.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;http协议&quot;&gt;&lt;a href=&quot;#http协议&quot; class=&quot;headerlink&quot; title=&quot;http协议&quot;&gt;&lt;/a&gt;http协议&lt;/h1&gt;&lt;p&gt;前一阵子跟着宋红康老师学了一遍 jvm, 收获颇深. 因为追求看视频的速度问题所以没有去做笔记. 后期回忆起</summary>
      
    
    
    
    <category term="网络" scheme="http://yiiiqing.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="http" scheme="http://yiiiqing.github.io/tags/http/"/>
    
    <category term="tcp" scheme="http://yiiiqing.github.io/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Docker启动常用工具大全</title>
    <link href="http://yiiiqing.github.io/2021/10/18/Docker%E5%90%AF%E5%8A%A8%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8/"/>
    <id>http://yiiiqing.github.io/2021/10/18/Docker%E5%90%AF%E5%8A%A8%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%A4%A7%E5%85%A8/</id>
    <published>2021-10-18T10:43:45.000Z</published>
    <updated>2021-10-18T11:29:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-启动常用工具大全"><a href="#Docker-启动常用工具大全" class="headerlink" title="Docker 启动常用工具大全"></a>Docker 启动常用工具大全</h1><p>平时经常使用 docker 启动一些服务, 比如数据库, redis, es 什么的, 每一个启动命令都不一样. 在这里统一做一个总结.</p><p>docker hub 镜像仓库地址: <a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo:latest</span><br><span class="line">docker run -itd --name mongo -p 27017:27017 mongo --auth</span><br></pre></td></tr></table></figure><p>–auth: 需要密码才能访问容器服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it mongo mongo admin</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个名为 admin，密码为 123456 的用户。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash"> db.createUser(&#123; user:<span class="string">&#x27;admin&#x27;</span>,<span class="built_in">pwd</span>:<span class="string">&#x27;123456&#x27;</span>,roles:[ &#123; role:<span class="string">&#x27;userAdminAnyDatabase&#x27;</span>, db: <span class="string">&#x27;admin&#x27;</span>&#125;,<span class="string">&quot;readWriteAnyDatabase&quot;</span>]&#125;);</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">尝试使用上面创建的用户信息进行连接。</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.auth(<span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>)</span></span><br></pre></td></tr></table></figure><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p>注意选择 management 的版本才有网页端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull rabbitmq:3.7.14-management</span><br><span class="line">docker run -d -p 5672:5672 -p 15672:15672 --name rabbitmq rabbitmq:3.7.14-management</span><br></pre></td></tr></table></figure><p>然后打开<a href="http://localhost:15672/%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2">http://localhost:15672/可以看到管理界面</a></p><p>默认账号: guest</p><p>默认密码: guest</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Docker-启动常用工具大全&quot;&gt;&lt;a href=&quot;#Docker-启动常用工具大全&quot; class=&quot;headerlink&quot; title=&quot;Docker 启动常用工具大全&quot;&gt;&lt;/a&gt;Docker 启动常用工具大全&lt;/h1&gt;&lt;p&gt;平时经常使用 docker 启动一些</summary>
      
    
    
    
    <category term="Docker" scheme="http://yiiiqing.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://yiiiqing.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Java-单例模式实现</title>
    <link href="http://yiiiqing.github.io/2021/10/08/Java-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yiiiqing.github.io/2021/10/08/Java-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-10-08T12:52:50.000Z</published>
    <updated>2021-10-09T01:58:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java单例模式实现"><a href="#Java单例模式实现" class="headerlink" title="Java单例模式实现"></a>Java单例模式实现</h1><p>学习枚举类的时候看到了一篇文章, 其中大致总结了几种单例模式的写法, 正好我也抽空自己整理一下</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>什么是单例模式? 其实是一种最常使用的设计模式, 也就是确保某个类只有一个实例, 而且这个类能自行实例化并向整个系统提供这个实例.</p><p>应用在: 线程池, 缓存, 日志对象, 对话框对象等.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonHungry</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonHungry</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonHungry</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonHungry</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonHungry <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较简单的一种写法</p><p>在类加载的时候就会创建对象, 但是有一个问题就是如果这个类依赖于很多资源, 那么创建必定比较耗时. 所以我们希望他能够延迟加载, 减少初始化负载, 从而就有了懒汉式单例实现</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonLazy</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> SingletonLazy singletonLazy;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonLazy</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SingletonLazy <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singletonLazy == <span class="literal">null</span>) &#123;</span><br><span class="line">      singletonLazy = <span class="keyword">new</span> <span class="title class_">SingletonLazy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonLazy;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写, 就具备了懒加载的特点. 并且为了能够在多线程中更好的工作, 加入了 synchronized 关键字. 优点自然是可以更好的同步, 缺点就是因为 synchronized, 效率会变低.</p><blockquote><p>volatile 关键字打算再另一篇里面写, 简单描述一下就是:</p><p>第一层语义是可见性，可见性是指在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），所以其它线程会马上读取到已修改的值，关于工作内存和主内存可简单理解为高速缓存（直接与CPU打交道）和主存（日常所说的内存条），注意工作内存是线程独享的，主存是线程共享的。volatile的第二层语义是禁止指令重排序优化，我们写的代码（特别是多线程代码），由于编译器优化，在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同，这在单线程并没什么问题，然而一旦引入多线程环境，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题，值得关注的是volatile的禁止指令重排序优化功能在Java 1.5后才得以实现，因此1.5前的版本仍然是不安全的，即使使用了volatile关键字。</p></blockquote><p>为了优化这个缺点, 在单线程的情况下, 去掉 synchronized 关键字.</p><h3 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Singleton</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="literal">null</span>) &#123;</span><br><span class="line">          singleton = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁进行了两次 null 检查. 因为在 getSinleton 调用的时候并没有进入同步代码, 外面的检查是并发的, 并且过滤了绝大多数的 null 检查. 当出现 null 的时候进入同步代码再进行一次检查. </p><p>这样极大提升了并发度, 也提升了性能.</p><p>但是有一个问题, 就是 volatile 关键字是 1.5 才实现的禁止指令重排, 所以可以使用静态内部类</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonInner</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">SingletonInner</span> <span class="variable">singleton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SingletonInner</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">SingletonInner</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> SingletonInner <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Holder.singleton;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把Singleton实例放到一个静态内部类中，这样可以避免了静态实例在Singleton类的加载阶段（类加载过程的其中一个阶段的，此时只创建了Class对象）就创建对象，毕竟静态变量初始化是在SingletonInner类初始化时触发的，并且由于静态内部类只会被加载一次，所以这种写法也是线程安全的</p><h2 id="共同缺点"><a href="#共同缺点" class="headerlink" title="共同缺点"></a>共同缺点</h2><ol><li><p>序列化可能会破坏单例模式. 因为每次反序列化一个序列化的对象会创建一个新的实例, 解决方案:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;     </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();     </span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;     </span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line">   <span class="comment">//反序列时直接返回当前INSTANCE</span></span><br><span class="line">   <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;     </span><br><span class="line">     <span class="keyword">return</span> INSTANCE;     </span><br><span class="line">   &#125;    </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p>使用反射强行调用私有构造器. 解决方案: 修改构造器, 让他在创建第二个实例的时候抛异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();     </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span>  <span class="type">boolean</span>  <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    flag = <span class="literal">false</span>;   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;The instance  already exists ！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>上面的四类模式有了, 共同的缺点也能解决了, 但是代码复杂度也上去了, 更高效的方法就是枚举单例.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SingletonEnum</span> &#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无比简洁!</p><p>使用枚举单例我们还不需要考虑序列化和反射的问题, 因为枚举序列化是由jvm保证的，每一个枚举类型和定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了特殊的规定：在序列化时Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象。同时，编译器是不允许任何对这种序列化机制的定制的并禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法，从而保证了枚举实例的唯一性</p><p>这里要深入了解可以查看 Enum 类的 valueOf 方法.</p><p>总结就是: <strong>创建枚举实例只有编译器能做到</strong></p><p>单例模式的几个<strong>重点</strong>需要我们一直注意:</p><ul><li>线程安全</li><li>延迟加载</li><li>序列化与反序列化安全</li><li>反射安全</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java单例模式实现&quot;&gt;&lt;a href=&quot;#Java单例模式实现&quot; class=&quot;headerlink&quot; title=&quot;Java单例模式实现&quot;&gt;&lt;/a&gt;Java单例模式实现&lt;/h1&gt;&lt;p&gt;学习枚举类的时候看到了一篇文章, 其中大致总结了几种单例模式的写法, 正好我</summary>
      
    
    
    
    <category term="设计模式" scheme="http://yiiiqing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="Java" scheme="http://yiiiqing.github.io/tags/Java/"/>
    
    <category term="单例模式" scheme="http://yiiiqing.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>make命令</title>
    <link href="http://yiiiqing.github.io/2021/09/26/make%E5%91%BD%E4%BB%A4/"/>
    <id>http://yiiiqing.github.io/2021/09/26/make%E5%91%BD%E4%BB%A4/</id>
    <published>2021-09-26T14:06:14.000Z</published>
    <updated>2021-09-26T14:09:10.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="make-命令"><a href="#make-命令" class="headerlink" title="make 命令"></a>make 命令</h1><p>最近工作中看到了 make 命令</p><p>直接看这个教程简单学了一下<a href="https://www.ruanyifeng.com/blog/2015/02/make.html">https://www.ruanyifeng.com/blog/2015/02/make.html</a></p><p>有空自己再补</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;make-命令&quot;&gt;&lt;a href=&quot;#make-命令&quot; class=&quot;headerlink&quot; title=&quot;make 命令&quot;&gt;&lt;/a&gt;make 命令&lt;/h1&gt;&lt;p&gt;最近工作中看到了 make 命令&lt;/p&gt;
&lt;p&gt;直接看这个教程简单学了一下&lt;a href=&quot;http</summary>
      
    
    
    
    <category term="Linux" scheme="http://yiiiqing.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yiiiqing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>tmux使用</title>
    <link href="http://yiiiqing.github.io/2021/09/26/tmux%E4%BD%BF%E7%94%A8/"/>
    <id>http://yiiiqing.github.io/2021/09/26/tmux%E4%BD%BF%E7%94%A8/</id>
    <published>2021-09-26T13:39:23.000Z</published>
    <updated>2021-09-26T13:48:45.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="tmux-使用"><a href="#tmux-使用" class="headerlink" title="tmux 使用"></a>tmux 使用</h1><p>最近项目中需要 ssh 到堡垒机上运行一个脚本, 但是由于SRE那边的设置, 连接一段时间后就会断开连接. 导致长时间脚本立刻停止运行</p><p>然后发现使用 tmux 可以解决这个问题</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>tmux 的英文名是 terminal multiplexer, 荣用户可以在一个终端内管理多个分离的会话</p><p><strong>优点: 不受断网影响, 可以保存工作进度</strong></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>正常情况下, ssh 到 server, 当 ssh 断掉之后, server 会 kill 掉程序</p><h3 id="如果使用-tmux"><a href="#如果使用-tmux" class="headerlink" title="如果使用 tmux"></a>如果使用 tmux</h3><p>tmux 这边采用 c/s 结构, 键入 tmux, tmux 服务器会启动, 并创建一个 session. 也就是一个 bash 环境. 重点是这个环境是与当前 ssh 连接独立. 这样 ssh 断开不会影响这个 session.</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入Linux机器</span></span><br><span class="line">ssh &lt;your host name&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装tmux</span></span><br><span class="line">sudo apt install tmux </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">对每一个需要持续运行的程序</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> &lt;your working directory&gt; <span class="comment"># go to the corresponding working drectory</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tmux new -s &lt;your session name&gt; <span class="comment"># create new tmux session</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">&lt;<span class="built_in">command</span> to start your server&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">control + b d  <span class="comment"># to detach</span></span></span><br></pre></td></tr></table></figure><h2 id="常用-tmux-命令"><a href="#常用-tmux-命令" class="headerlink" title="常用 tmux 命令"></a>常用 tmux 命令</h2><h4 id="在-shell-主进程下，-可以用以下命令操作-tmux-session"><a href="#在-shell-主进程下，-可以用以下命令操作-tmux-session" class="headerlink" title="在 shell 主进程下， 可以用以下命令操作 tmux session"></a>在 shell 主进程下， 可以用以下命令操作 tmux session</h4><table><thead><tr><th><strong>Function（作用）</strong></th><th><strong>Command （命令）</strong></th></tr></thead><tbody><tr><td>新建有命名的 tmux session</td><td><code>tmux new -s session-name</code></td></tr><tr><td>列出所有 tmux session</td><td><code>tmux ls</code></td></tr><tr><td>进入上一次的 tmux session</td><td><code>tmux a</code> (<code>a</code> 指 <code>attach</code> )</td></tr><tr><td>进入名称为 test 的 tmux session</td><td><code>tmux a -t test</code> （<code>-t</code> 指  <code>target</code>）</td></tr><tr><td>删除名称为 test 的 tmux session</td><td><code>tmux kill-session -t test</code></td></tr><tr><td>删除所有的 tmux session</td><td><code>tmux kill-server</code></td></tr></tbody></table><h4 id="在-tmux-session下，-可以用以下命令操作-tmux-session"><a href="#在-tmux-session下，-可以用以下命令操作-tmux-session" class="headerlink" title="在 tmux session下， 可以用以下命令操作 tmux session"></a>在 tmux session下， 可以用以下命令操作 tmux session</h4><p>先按前缀快捷键 <code>control+b</code></p><ul><li><code>$</code> 重命名当前session</li><li><code>s</code> 弹出列表，可以选择进入不同 session</li><li><code>d</code> detach sessio，返回至 shell 主进程</li></ul><h2 id="tmux-其他用处"><a href="#tmux-其他用处" class="headerlink" title="tmux 其他用处"></a>tmux 其他用处</h2><p>可以屏幕共享, 如果 A 创建一个 session, B ssh 到此机器 tmux attach session, 这样 A 和 B 就可以看到互相的 session 的操作.</p><p>参考资料</p><ol><li><a href="https://www.cxyzjd.com/article/u014261408/89931729">https://www.cxyzjd.com/article/u014261408/89931729</a></li><li><a href="https://www.jianshu.com/p/8be9e77f4284">https://www.jianshu.com/p/8be9e77f4284</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;tmux-使用&quot;&gt;&lt;a href=&quot;#tmux-使用&quot; class=&quot;headerlink&quot; title=&quot;tmux 使用&quot;&gt;&lt;/a&gt;tmux 使用&lt;/h1&gt;&lt;p&gt;最近项目中需要 ssh 到堡垒机上运行一个脚本, 但是由于SRE那边的设置, 连接一段时间后就会断开</summary>
      
    
    
    
    <category term="Linux" scheme="http://yiiiqing.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="http://yiiiqing.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理学习笔记</title>
    <link href="http://yiiiqing.github.io/2021/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yiiiqing.github.io/2021/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2021-09-26T02:19:52.000Z</published>
    <updated>2021-10-18T03:44:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理学习笔记"><a href="#计算机组成原理学习笔记" class="headerlink" title="计算机组成原理学习笔记"></a>计算机组成原理学习笔记</h1><p>最近发现自己离科班出身差了”挂科四大件”</p><ul><li>计算机组成原理</li><li>操作系统</li><li>数据结构(已完成)</li><li>计算机网络</li></ul><p>其中数据结构学习了”大话数据结构”这本书,基本算是没问题. 正在通过刷算法题强化算法. 未来会啃一遍算法第四版</p><p>现在开始学习计算机组成!</p><p>==学习是跟着 b 站的视频学习的, 所以其实也包含了很多视频的截图.== 视频地址:<a href="https://www.bilibili.com/video/BV1BE411D7ii?p=1">https://www.bilibili.com/video/BV1BE411D7ii?p=1</a></p><h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h1><h3 id="1-1-计算机分类与发展方向"><a href="#1-1-计算机分类与发展方向" class="headerlink" title="1.1 计算机分类与发展方向"></a>1.1 计算机分类与发展方向</h3><h2 id="1-2-结构"><a href="#1-2-结构" class="headerlink" title="1.2 结构"></a>1.2 结构</h2><h3 id="1-2-1-系统结构"><a href="#1-2-1-系统结构" class="headerlink" title="1.2.1 系统结构"></a>1.2.1 系统结构</h3><h4 id="指令和数据流"><a href="#指令和数据流" class="headerlink" title="指令和数据流"></a>指令和数据流</h4><ol><li>单指令&amp;单数据流 SISD: 冯诺依曼体系结构<ol><li>冯诺依曼体系结构见博客: <a href="https://blog.csdn.net/fayfayfaydyt/article/details/81603250">https://blog.csdn.net/fayfayfaydyt/article/details/81603250</a></li></ol></li><li>单指令流&amp;多数据流 SIMD: 阵列处理器, 向量处理器</li><li>多指令流&amp;单数据流 MISD: 实际不存在</li><li>多指令流&amp;多数据流 MIMD: 多处理器, 多计算机. 类似分布式</li></ol><p><img src="/image-20210926114624898.png" alt="image-20210926114624898"></p><p>左上角为冯诺依曼结构计算机</p><p>右上角为现代结构计算机</p><p><strong>注意理解图中各个箭头的意义</strong></p><blockquote><p>个人理解:</p><ol><li>计算机是输入到输出, 所以要有输入设备和输出设备</li><li>输入到输出需要计算,所以左上角图中,中间由运算器连接</li><li>整个流程需要控制, 所以输入输出运算器均由控制器控制(虚线)</li><li>我们需要让输入连续一串,而不是一个一个,所以需要地方存储输入的数据和指令, 所以有了存储器,存储器与运算器直接数据交互</li><li>又因为控制器需要控制逻辑运算流程,所以存储器和控制器也直接数据交互(左上角图完成)</li><li>如果将运算器独立出来作为运算职能, 将存储器与运算器位置交换, 可以得到右上角图. 右上角图的优势是<strong>总线变宽</strong></li></ol></blockquote><p>上面两张图进行分类得到左下角的图, 可以知道 CPU 和 IO 设备的由来, 这也就组成了右下角的计算机</p><h3 id="1-2-2-CPU-及工作过程"><a href="#1-2-2-CPU-及工作过程" class="headerlink" title="1.2.2 CPU 及工作过程"></a>1.2.2 CPU 及工作过程</h3><p>==cpu 的任务: 到内存中取指令; 按指令的指示进行下一步工作==</p><h4 id="运算器和控制器"><a href="#运算器和控制器" class="headerlink" title="运算器和控制器"></a>运算器和控制器</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210927112611856.png" alt="image-20210927112611856"></p><h4 id="计算机工作过程-取数指令"><a href="#计算机工作过程-取数指令" class="headerlink" title="计算机工作过程-取数指令"></a>计算机工作过程-取数指令</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210927114503013.png" alt="image-20210927114503013"></p><h3 id="1-2-3-I-O-设备"><a href="#1-2-3-I-O-设备" class="headerlink" title="1.2.3 I/O 设备"></a>1.2.3 I/O 设备</h3><h3 id="1-2-4-软件系统"><a href="#1-2-4-软件系统" class="headerlink" title="1.2.4 软件系统"></a>1.2.4 软件系统</h3><h4 id="机器语言-二进制代码"><a href="#机器语言-二进制代码" class="headerlink" title="机器语言: 二进制代码"></a>机器语言: 二进制代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0000,0000,000000010000</span><br></pre></td></tr></table></figure><p>如果 0000 代表 LOAD 操作, 0001 代表 STORE 操作. 可以使用汇编语言使人类能看懂</p><h4 id="汇编语言-Assembly-language-助记符"><a href="#汇编语言-Assembly-language-助记符" class="headerlink" title="汇编语言 Assembly language : 助记符"></a>汇编语言 Assembly language : 助记符</h4><p>所以, 汇编语言也就是一种助记符.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOAD A,16</span><br></pre></td></tr></table></figure><p>16 号单元数据与 17 号单元数据相加存回 17 号单元:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LOAD A,16</span><br><span class="line">LOAD B,17</span><br><span class="line">ADD C,A,B</span><br><span class="line">STORE C,17</span><br></pre></td></tr></table></figure><p><strong>汇编语言通过汇编器转换为机器语言</strong></p><p>汇编语言其实也不是我们平时在生活中使用的符号, 所以就有了高级语言</p><h4 id="高级语言-C-C-Java"><a href="#高级语言-C-C-Java" class="headerlink" title="高级语言: C/C++, Java"></a>高级语言: C/C++, Java</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = a + b</span><br><span class="line">d = a + b</span><br><span class="line">e = b + c</span><br></pre></td></tr></table></figure><p><strong>高级语言通过编译器编译为汇编语言</strong></p><h3 id="1-2-5-计算机系统的层次结构"><a href="#1-2-5-计算机系统的层次结构" class="headerlink" title="1.2.5 计算机系统的层次结构"></a>1.2.5 计算机系统的层次结构</h3><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928104315365.png" alt="image-20210928104315365"></p><p>微指令是为了复用机器指令</p><h4 id="冯诺依曼计算机"><a href="#冯诺依曼计算机" class="headerlink" title="冯诺依曼计算机"></a>冯诺依曼计算机</h4><p>“存储程序”: 将指令以代码的形式实现输入到计算机主存储器中, 然后按其在存储器中的首地址执行程序的第一条指令, 以后就按照程序的规定顺序执行其他指令, 直至程序执行结束.</p><ol><li>计算机硬件由运算器,存储器,控制器,输入设备,输出设备 5 大部件</li><li>指令和数据以同等地位存于存储器内,并可按地址寻访</li><li>指令和数据军用二进制码表示</li><li>指令由操作码和地址码组成, 操作码用来表示操作的性质, 地址码用来表示操作数在存储器中的位置</li><li>指令在存储器内按顺序存放. 通常指令是顺序执行的, 特定条件可以根据设定的条件改变</li><li>早期的冯诺依曼机以运算器为中心, 输入/输出设备通过运算器与存储器传送数据</li></ol><h3 id="1-2-6-存储器"><a href="#1-2-6-存储器" class="headerlink" title="1.2.6 存储器"></a>1.2.6 存储器</h3><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928110329600.png" alt="image-20210928110329600"></p><p>注意存储元的存储原理</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928110751073.png" alt="image-20210928110751073"></p><blockquote><p>我们将诸多的存储元放在一行构成了存储单元. 许多存储单元构成了存储体</p><p>图中绿色线表示连通的, 所以我们需要图中的红色线来表明我们取的是哪一行存储单元. 红色线的数值用 0 和 1 表示,1 表示选取该行.</p><p>于是有了另一个设备: 译码器. 用来指定输入/输出的存储单元. 因为用二进制表示, 所以 3 根输入线可以表示 8 排存储单元. 图中的设备名为 3-8 译码器</p></blockquote><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928111430161.png" alt="image-20210928111430161"></p><p>尽管设计上 MDR 和 MAR 是属于内存, 但是实现上是放在了 CPU 中的, 目的是为了加快速度</p><h2 id="1-3-性能指标"><a href="#1-3-性能指标" class="headerlink" title="1.3 性能指标"></a>1.3 性能指标</h2><h3 id="1-3-1-容量"><a href="#1-3-1-容量" class="headerlink" title="1.3.1 容量"></a>1.3.1 容量</h3><p>首先得了解一下存储器的容量</p><p>![image-20210928113143786](/Users/yiqing/Library/Application Support/typora-user-images/image-20210928113143786.png)</p><p>一个存储元只能存储二进制的一位, 也就是一个 bit. 一个存储单元是八个存储元,也就是 1Byte</p><p>所以可以计算出总容量</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928113438814.png" alt="image-20210928113438814"></p><p>译码器依赖于地址寄存器. 如果译码器加一根线, 可以支持的存储单元就多一倍. 所以系统所能支持的最大容量<strong>取决于地址寄存器</strong>.</p><p>已经达到上限的话,添加右侧的存储单元也是无意义的.</p><h3 id="1-3-2-速度"><a href="#1-3-2-速度" class="headerlink" title="1.3.2 速度"></a>1.3.2 速度</h3><p>几个方面可以衡量计算机的速度</p><h4 id="CPU-执行速度"><a href="#CPU-执行速度" class="headerlink" title="CPU 执行速度"></a>CPU 执行速度</h4><p>时钟周期的倒数就是主频 ![image-20210928144404954](/Users/yiqing/Library/Application Support/typora-user-images/image-20210928144404954.png)</p><ul><li>MIPS (Million Instructions Per Second): 每秒执行多少百万条指令</li></ul><h4 id="数据通路带宽"><a href="#数据通路带宽" class="headerlink" title="数据通路带宽"></a>数据通路带宽</h4><p>数据总线一次所能并行传送信息的位数</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>系统在单位时间内处理请求的数量</p><h4 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h4><p>指从用户向计算机发送一个请求,到系统对该请求做出相应并获得它所需要的结果的等待时间.</p><p>通常包括 CPU 时间,与等待时间(磁盘,存储器,IO,系统开销)</p><h1 id="2-数制与编码"><a href="#2-数制与编码" class="headerlink" title="2 数制与编码"></a>2 数制与编码</h1><h2 id="2-1-计数法和编码"><a href="#2-1-计数法和编码" class="headerlink" title="2.1 计数法和编码"></a>2.1 计数法和编码</h2><h3 id="2-1-1-进数计数法"><a href="#2-1-1-进数计数法" class="headerlink" title="2.1.1 进数计数法"></a>2.1.1 进数计数法</h3><p>基数: 每个数位所用到的不同符号的个数</p><table><thead><tr><th></th><th>基数大(十进制)</th><th>基数小(二进制)</th></tr></thead><tbody><tr><td>位数</td><td>少</td><td>多</td></tr><tr><td>运算(乘法为例)</td><td>100 种情况(10*10)</td><td>4 种情况(2*2)</td></tr></tbody></table><p><strong>计算机选择二进制的原因</strong>: 方便对应到物理器件的状态, 如高电平, 低电平</p><h3 id="2-1-2-进制转换-重点"><a href="#2-1-2-进制转换-重点" class="headerlink" title="2.1.2 进制转换 (重点)"></a>2.1.2 进制转换 (重点)</h3><p>进制说白了只是因为每一位的权值不同, 比如 75 = 7 * 10 + 5</p><p>这个权重叫做位权</p><h4 id="十进制和任意进制的转换"><a href="#十进制和任意进制的转换" class="headerlink" title="十进制和任意进制的转换"></a>十进制和任意进制的转换</h4><p>根据位权的推算, 我们可以通过一种<strong>除基取余法</strong>来转换.</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928175015427.png" alt="image-20210928175015427"></p><h4 id="二进制和其他进制的转换"><a href="#二进制和其他进制的转换" class="headerlink" title="二进制和其他进制的转换"></a>二进制和其他进制的转换</h4><p><strong>n 位一组法</strong></p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928175506576.png" alt="image-20210928175506576"></p><h4 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928175642965.png" alt="image-20210928175642965"></p><h3 id="2-1-3-BCD-码"><a href="#2-1-3-BCD-码" class="headerlink" title="2.1.3 BCD 码"></a>2.1.3 BCD 码</h3><p>BCD 即 Binary Coded Decimal</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210928192311421.png" alt="image-20210928192311421"></p><p>注意如果超出 9, 则不在映射表中, 这种情况需要加 6</p><p>叫做<strong>加6修正</strong></p><blockquote><p>我感觉就是模拟十进制的进位, 使二进制表示方法下进位</p></blockquote><p>除了 8421 码还有:</p><ul><li>余 3 码, 其实也就是将 8421 平移了</li><li>2421 码, 也就是将最高位权重变为 2</li></ul><h3 id="2-1-4-字符"><a href="#2-1-4-字符" class="headerlink" title="2.1.4 字符"></a>2.1.4 字符</h3><p>ASCII 码:</p><p>大写字母: 65-90</p><p>小写字母: 97-122</p><p><strong>需要记住的是 A 是 65</strong></p><p>而且实际存放的是 ASCII 码对应的二进制形式</p><h3 id="2-1-5-奇偶校验"><a href="#2-1-5-奇偶校验" class="headerlink" title="2.1.5 奇偶校验"></a>2.1.5 奇偶校验</h3><p>码距: 两个合法码字对应位上数字的不同位的个数</p><p>奇偶校验其实就是增加了一个校验位, 用来使整个奇偶校验码”1”的个数为奇数或偶数</p><p>示例: 给出两个编码 1001101 和 1010111 的奇校验码和偶校验码</p><p>假设最高位为校验位, 剩下 7 位为信息位, 则对应的奇偶校验码为:</p><p>奇校验: <u>1</u>1001101    <u>0</u>1010111 (第一个本身 1 不是奇数个,加一个 1 变成奇数个, 第二个本身就是奇数个,所以补一个 0)</p><p>偶校验: <u>0</u>1001101    <u>1</u>1010111</p><h3 id="2-1-6-汉明码"><a href="#2-1-6-汉明码" class="headerlink" title="2.1.6 汉明码"></a>2.1.6 汉明码</h3><p>汉明码的设计思路: 分组校验 -&gt; 多个校验位 -&gt; 校验位标注出错位置</p><p>汉明码的实际过程和校验方法略</p><h3 id="2-1-7-循环冗余校验码"><a href="#2-1-7-循环冗余校验码" class="headerlink" title="2.1.7 循环冗余校验码"></a>2.1.7 循环冗余校验码</h3><p>略</p><h2 id="2-2-定点数的表示和运算"><a href="#2-2-定点数的表示和运算" class="headerlink" title="2.2 定点数的表示和运算"></a>2.2 定点数的表示和运算</h2><h3 id="2-2-1-无符号数和及原码"><a href="#2-2-1-无符号数和及原码" class="headerlink" title="2.2.1 无符号数和及原码"></a>2.2.1 无符号数和及原码</h3><p>无符号数: 整个机器字长的全部二进制位均为数值位, 没有符号位, 相当于数的绝对值</p><p>原码: 就是符号位加上了绝对值, 把正号变为 0,把符号变为 1.</p><h3 id="2-2-2-补码反码移码"><a href="#2-2-2-补码反码移码" class="headerlink" title="2.2.2 补码反码移码"></a>2.2.2 补码反码移码</h3><h4 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h4><p>对于正数, 补码与原码的表示相同</p><p>对于负数, 原码符号位不变, 数值部分按位取反, 末位加一 (即所谓”取反加一”) </p><p><strong>补码的作用: 使用补码可以将减法操作转变为等价的加法, ALU 中无须集成减法器. 执行加法操作后, 符号位一起参与运算</strong></p><blockquote><p>计算机在执行有符号数的减法很麻烦, 想办法将其转换为加法, 利用的就是取模的原理, 因为计算机会天然的取 $2^8$ 的模. 所以我们想办法让两个数相加溢出一位, 将结果等于取 $2^8$ 的模的结果即可将减法等价于加法. 这时候就将八位的二进制取反+1,使得运算结果超出$2^8$, 计算机自动取模得到等价的减法操作. (重点理解)</p><p>取反加一的加一操作原因: 因为如果不加一, 某一个数取反之后何其原本相加为八个一, 11111111.  加一之后为 100000000. 即 $2^8$ .为我们所需要的模</p></blockquote><h4 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h4><p>对于正数, 反码与原码的表示相同</p><p>对于负数,原码符号位不变,数值部分按位取反(也就是求补码的中间状态)</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20210929133303848.png" alt="image-20210929133303848"></p><p>核心就是这张图</p><h3 id="2-2-3-移位运算"><a href="#2-2-3-移位运算" class="headerlink" title="2.2.3 移位运算"></a>2.2.3 移位运算</h3><p>我们日常使用的十进制, 可以通过小数点左移或者右移, 实现 /10 或者 *10操作.</p><h4 id="原码的算数移位"><a href="#原码的算数移位" class="headerlink" title="原码的算数移位"></a>原码的算数移位</h4><p><strong>符号位保持不变, 仅对数值位进行移位.</strong></p><p><strong>右移: 高位补零,低位舍弃</strong>. 若舍弃的位等于 0, 则相当于除以 2; 若舍弃的位不等于 0, 则相当于丢失精度.</p><p>右移一位: $\div 2^1$; 右移两位: $\div 2^2$; 右移三位: $\div 2^3$</p><p><strong>左移: 低位补零, 高位舍弃</strong>. 若舍弃的位等于 0, 则相当于乘以 2; 若舍弃的位不等于 0, 则会出现严重误差. (原因左移表示至少乘以二,但是因为最高位为 1 的话, 乘以二绝对会超出 7 位 bit 表示的范围)</p><h4 id="反码的算数移位"><a href="#反码的算数移位" class="headerlink" title="反码的算数移位"></a>反码的算数移位</h4><p>正数的反码与原码相同. 因此对正数的反码移位和原码相同.</p><p>负数的反码数值为与原码想反. 因此负数反码的移位运算规则如下: 右移: 高位补1,低位舍弃. 左移:低位补 1,高位舍弃.(其实就是从补0变成了补1)</p><h4 id="补码的算数移位"><a href="#补码的算数移位" class="headerlink" title="补码的算数移位"></a>补码的算数移位</h4><p>正数的补码与原码相同. 因此对正数的补码移位和原码相同.</p><p>负数: 因为负数的补码是反码+1.导致反码最右边几个连续的1 都将会边为 0, 知道进位变成第一个 0 为止. 规律: <strong>负数补码时,最右边的 1 及其右边同原码, 最右边的 1 的左边同反码</strong>. 所以负数补码的移位运算规则如下: 右移(同反码): 高位补 1, 低位舍弃; 左移(同原码): 低位补 1,高位舍弃.</p><h3 id="2-2-4-加减运算和溢出运算"><a href="#2-2-4-加减运算和溢出运算" class="headerlink" title="2.2.4 加减运算和溢出运算"></a>2.2.4 加减运算和溢出运算</h3><h3 id="2-2-5-乘法运算"><a href="#2-2-5-乘法运算" class="headerlink" title="2.2.5 乘法运算"></a>2.2.5 乘法运算</h3><h3 id="2-2-6-除法运算"><a href="#2-2-6-除法运算" class="headerlink" title="2.2.6 除法运算"></a>2.2.6 除法运算</h3><h3 id="2-2-7-强制类型转换"><a href="#2-2-7-强制类型转换" class="headerlink" title="2.2.7 强制类型转换"></a>2.2.7 强制类型转换</h3><p>以上小节略过</p><h3 id="2-2-8-数据的存储和排列"><a href="#2-2-8-数据的存储和排列" class="headerlink" title="2.2.8 数据的存储和排列"></a>2.2.8 数据的存储和排列</h3><h4 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h4><p>对于 4 字节的 int 类型, 将最高一个字节称为最高有效字节(MSB), 将最低一个字节称为最低有效字节(LSB). 而且一个 int 几个字节都是连续的.</p><p>大端方式: 将最高有效字节存放在低地址. (便于人类阅读)</p><p>小端方式: 将最低有效字节存放在低地址. (便于机器处理, 如果 cpu 只能处理 8 位, 显然应该从最低的八位开始相加)</p><h2 id="2-3-浮点数"><a href="#2-3-浮点数" class="headerlink" title="2.3 浮点数"></a>2.3 浮点数</h2><h3 id="2-3-4-浮点数的表示"><a href="#2-3-4-浮点数的表示" class="headerlink" title="2.3.4 浮点数的表示"></a>2.3.4 浮点数的表示</h3><p>定点数可表示的数字范围悠闲, 但我们不要无限制地增加数据的长度. 所以, <strong>如何在位数不变的情况下增加数据的表示范围?</strong></p><p>浮点数将数分成阶码和尾数两个部分.</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211003201725016.png" alt="image-20211003201725016"></p><p><strong>规格化浮点数: 规定尾数的最高位必须是一个有效值</strong></p><p>左规: 当浮点数运算结果为非规格化时要进行规格化处理, 将<strong>尾数算数左移一位, 阶码减一</strong>.</p><p>右规: 当浮点数运算结果尾数出现溢出(双符号位为 01 或 10), 将<strong>尾数算数右移一位, 阶码加一</strong>.</p><p>之所以采用双符号位就是为了当溢出发生时进行挽救. <strong>更高的符号位是正确的符号位</strong></p><h3 id="2-3-2-IEEE754-标准"><a href="#2-3-2-IEEE754-标准" class="headerlink" title="2.3.2 IEEE754 标准"></a>2.3.2 IEEE754 标准</h3><h3 id="2-4-3-浮点数的运算"><a href="#2-4-3-浮点数的运算" class="headerlink" title="2.4.3 浮点数的运算"></a>2.4.3 浮点数的运算</h3><p>运算略</p><h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>char -&gt; int -&gt; long -&gt; double 不会损失精度(前提是32 位机器,因为在 32 位机器 long 占用 32 位, 64 位中long 占用 64 位,但是 double 的尾数位只有 53 位, 所以一定会损失精度)</p><p>float -&gt; double 不会损失精度</p><p>int -&gt; float 可能丢失精度</p><p>float -&gt; int 可能溢出(表示了超出 int 的小数)及损失精度(表示整数)</p><h2 id="2-4-算数逻辑单元-ALU"><a href="#2-4-算数逻辑单元-ALU" class="headerlink" title="2.4 算数逻辑单元 ALU"></a>2.4 算数逻辑单元 ALU</h2><h3 id="2-4-1-电路的基本原理-加法器设计"><a href="#2-4-1-电路的基本原理-加法器设计" class="headerlink" title="2.4.1 电路的基本原理, 加法器设计"></a>2.4.1 电路的基本原理, 加法器设计</h3><p><strong>逻辑表达式其实就是电路的数学化表示. 根据逻辑电路的规则对逻辑表达式进行优化, 其实就是在优化电路</strong></p><p>算术运算: 加减乘除等</p><p>逻辑运算: 与, 或, 非, 异或等</p><p>辅助功能: 移位, 求补</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211004102836382.png" alt="image-20211004102836382"></p><p>此处需要复习门电路</p><h4 id="一位全加器"><a href="#一位全加器" class="headerlink" title="一位全加器"></a>一位全加器</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211004113120708.png" alt="image-20211004113120708"></p><p>注意去理解如何将二进制加法 -&gt; 逻辑表达式 -&gt; 逻辑门电路 -&gt; 一位加法器</p><p>但是注意, 这个是一位的加法, 如何计算多位?</p><h4 id="串行加法器"><a href="#串行加法器" class="headerlink" title="串行加法器"></a>串行加法器</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211004113443083.png" alt="image-20211004113443083"></p><p>只能一位一位的加</p><h4 id="并行加法器"><a href="#并行加法器" class="headerlink" title="并行加法器"></a>并行加法器</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211004113654094.png" alt="image-20211004113654094"></p><p>典型的<strong>空间换时间</strong></p><p>并行加法器的速度取决于每一个加法器的速度</p><h3 id="2-4-2-ALU-的改进"><a href="#2-4-2-ALU-的改进" class="headerlink" title="2.4.2 ALU 的改进"></a>2.4.2 ALU 的改进</h3><p>串行加法器 -&gt; 串行进位的并行加法器 -&gt; 组内并行, 组间串行进位的加法器 -&gt; 组内并行, 组间并行的加法器</p><h1 id="3-存储系统"><a href="#3-存储系统" class="headerlink" title="3 存储系统"></a>3 存储系统</h1><h2 id="3-1-存储系统"><a href="#3-1-存储系统" class="headerlink" title="3.1 存储系统"></a>3.1 存储系统</h2><h3 id="3-1-1-主存简单模型"><a href="#3-1-1-主存简单模型" class="headerlink" title="3.1.1 主存简单模型"></a>3.1.1 主存简单模型</h3><p>主存储器包括存储体, MAR(地址寄存器)和 MDR(数据寄存器)三个部分.</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211004224706173.png" alt="image-20211004224706173"></p><p>联想到之前学的存储元的知识, 直接联系起来了.</p><h2 id="3-2-寻址概念"><a href="#3-2-寻址概念" class="headerlink" title="3.2 寻址概念"></a>3.2 寻址概念</h2><h2 id="3-3-存储器"><a href="#3-3-存储器" class="headerlink" title="3.3 存储器"></a>3.3 存储器</h2><h3 id="3-3-1-半导体存储器-RAM-Random-Access-Memory"><a href="#3-3-1-半导体存储器-RAM-Random-Access-Memory" class="headerlink" title="3.3.1 半导体存储器 RAM (Random-Access Memory)"></a>3.3.1 半导体存储器 RAM (Random-Access Memory)</h3><p>分为 SRAM (静态随机存储器) 和 DRAM (动态随机存储器) 两种</p><ul><li>SRAM: 触发器存储信息, 速度快, 成本高, 集成度低, 常用作高速缓存 Cache</li><li>DRAM: 电容存储信息, 需刷新, 速度慢, 成本低, 集成度高, 常用作主存(SDRAM)</li></ul><p>为什么要用行列地址? 减少选通线的数量</p><h3 id="3-3-2-半导体存储器-ROM-Read-Only-Memory"><a href="#3-3-2-半导体存储器-ROM-Read-Only-Memory" class="headerlink" title="3.3.2 半导体存储器 ROM (Read-Only Memory)"></a>3.3.2 半导体存储器 ROM (Read-Only Memory)</h3><p>CPU 包含了运算器, 控制器和主存储器.</p><p>因为 RAM 为易失性存储器. 如果采用 RAM 用来做主存, 一旦掉电将会丢失! 哪种不会丢失? 辅存. 但是由于辅存是通过 IO 接口连入主机, 所以就有了 ROM</p><p>ROM: 将辅存里的 OS 调到 RAM</p><p>ROM 经历了各种发展后, 目前使用固态硬盘为多. 但是固态硬盘依然无法替代 RAM, 但是正在逐步靠近.</p><blockquote><p>没有保存的文件断电就会消失原理就是因为这些文件其实保存在 RAM 里. 保存其实就是将 RAM 中的数据保存到辅存.</p><p>ROM 就是在开机时候告诉主机, 应该往 RAM 中放辅存的哪些内容</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211009103801571.png" alt="image-20211009103801571"></p><p>重点理解存储周期的概念</p><h3 id="3-3-3-存储器概念"><a href="#3-3-3-存储器概念" class="headerlink" title="3.3.3 存储器概念"></a>3.3.3 存储器概念</h3><p><strong>存储器的功能</strong>: 存放二进制信息</p><p>不同的材料, 不同的特性:</p><ol><li>磁表面存储器: 磁盘 (特点:直接存取, 先定位到一个小区域), 磁带(特点:顺序存取)</li><li>磁芯存储器</li><li>半导体存储器 (特点是随机存取, 存取时间与存储单元位置无关,仅与电流有关. eg: ROM,RAM(易失性))</li><li>光存储器</li></ol><p><strong>存储器的性能指标</strong></p><ol><li>存储容量: 存储字数 * 字长</li><li>单位成本: 每位价格=总成本/总容量</li><li>存储速度: 数据传输率=数据的宽度/存储周期</li></ol><p><strong>存储器的层次化结构</strong></p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211009104916672.png" alt="image-20211009104916672"></p><h2 id="3-4-主存与-CPU-的连接"><a href="#3-4-主存与-CPU-的连接" class="headerlink" title="3.4 主存与 CPU 的连接"></a>3.4 主存与 CPU 的连接</h2><p>片选线: 0 和 1 决定存储器工作与否</p><p>读写控制线: 0 和 1 决定读 or 写</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211009112930036.png" alt="image-20211009112930036"></p><p>cpu 想要处理 8 位的数据,则需要八个 8k1 位的存储器, 则有了下图, 这种扩展称为位扩展</p><h4 id="位扩展"><a href="#位扩展" class="headerlink" title="位扩展"></a>位扩展</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211009112842475.png" alt="image-20211009112842475"></p><h4 id="字扩展"><a href="#字扩展" class="headerlink" title="字扩展"></a>字扩展</h4><p>通过利用 cpu 上的 A13A14 操控使用哪一个存储器的数据, 本例只有 01 或 10, 也就是 n 条线 n 个片选信号</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211009113205551.png" alt="image-20211009113205551"></p><p>这种叫做<strong>线选法</strong></p><p>电路简单地址空间不连续</p><p>但是可见容量收到了输入线的数量的限制, 如何突破这种限制呢?</p><h4 id="主存容量扩展"><a href="#主存容量扩展" class="headerlink" title="主存容量扩展"></a>主存容量扩展</h4><p>使用译码器, 将三位转换成 2 的三次方位</p><p>图下这种方法称为<strong>译码片选法</strong>, 电路复杂,但是地址空间可连续, 可以增加逻辑设计</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211009115343866.png" alt="image-20211009115343866"></p><h4 id="字位同时扩展"><a href="#字位同时扩展" class="headerlink" title="字位同时扩展"></a>字位同时扩展</h4><p>略</p><h2 id="3-5-双口-RAM-和多模块存储器"><a href="#3-5-双口-RAM-和多模块存储器" class="headerlink" title="3.5 双口 RAM 和多模块存储器"></a>3.5 双口 RAM 和多模块存储器</h2><p>CPU 和主存之间存在着科技进步速度的差距</p><p>所以双口 RAM 和多模块存储器就是为了<strong>提高存储器的工作速度</strong></p><h4 id="存取周期"><a href="#存取周期" class="headerlink" title="存取周期"></a>存取周期</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211012095153828.png" alt="image-20211012095153828"> </p><h4 id="多体并行存储器"><a href="#多体并行存储器" class="headerlink" title="多体并行存储器"></a>多体并行存储器</h4><ul><li><p>高位交叉编址的多体存储器</p><ul><li>连续存取 n 个存储器耗时为 nT, n 个存取周期</li></ul></li><li><p>低位交叉编址的多体存储器</p><ul><li>这种方式省却了恢复时间, 所以在时间上会更快</li></ul></li><li><p>一个存储周期内, 交叉存储器可以提供的数据量为单个模块的 m 倍 (m 为模块数).</p></li><li><p>可以并行工作, 如总线宽度为 mW 时, 可以同时取出长度为 mW 的数据.</p></li></ul><h2 id="3-6-高速缓冲存储器"><a href="#3-6-高速缓冲存储器" class="headerlink" title="3.6 高速缓冲存储器"></a>3.6 高速缓冲存储器</h2><h3 id="3-6-1-局部性原理性能分析"><a href="#3-6-1-局部性原理性能分析" class="headerlink" title="3.6.1 局部性原理性能分析"></a>3.6.1 局部性原理性能分析</h3><p>通过多体并行存储器优化后, 速度与 CPU 差距仍然很大. 考虑更告诉的存储单元设计, 但是这样存储器价格会提升,容量会下降. 而且根据程序访问的局部性原理. 就有了高速缓存.</p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><ul><li>空间局部性: 在最近的未来要用到的信息(指令和数据), 很可能与现在正在使用的信息在存储空间上是临近的</li><li>时间局限性: 在最近的未来要用到的信息, 很可能是正在使用到的信息</li></ul><h4 id="命中率-H"><a href="#命中率-H" class="headerlink" title="命中率 H"></a>命中率 H</h4><p>CPU 欲访问的信息已在 Cache 中的比率</p><h3 id="3-6-2-Cache-地址映射"><a href="#3-6-2-Cache-地址映射" class="headerlink" title="3.6.2 Cache-地址映射"></a>3.6.2 Cache-地址映射</h3><p><strong>主存中的块放到 Cache 中的哪个位置?</strong></p><ol><li>空位随意放: 全相联映射</li><li>对号入座: 直接映射</li><li>按号分组, 组内随意放: 组相联映射</li></ol><p><strong>对于 1, Cache 满了如何处理? 对于 2,3, 对应位置被占用如何处理?</strong></p><p>随机算法, 先进先出算法, 近期最少使用(LRU)算法, 最不经常使用(LFU)算法.</p><p><strong>修改 Cache 中的内容后, 如何保持主存中相应内容的一致性?</strong></p><ul><li>命中: <ul><li>全写法(write-through)</li><li>回写法(write-back)</li></ul></li><li>不命中:<ul><li>写分配法(write-allocate)</li><li>非写分配法(not-write-allocate)</li></ul></li></ul><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211012105118303.png" alt="image-20211012105118303"></p><h3 id="3-6-3-替换算法和写策略"><a href="#3-6-3-替换算法和写策略" class="headerlink" title="3.6.3 替换算法和写策略"></a>3.6.3 替换算法和写策略</h3><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><ol><li><p>随机算法(RAND): 随机地确定替换的 Cache 块. 实现简单, 没有依据程序访问的局部性原理, 命中率较低.</p></li><li><p>先进先出算法(FIFO): 选择最早调入的行进行替换. 比较容易实现, 但也没有依据程序访问的局部性原理, 可能会把一些经常要使用的程序块(如循环程序)也作为最早进入 Cache 的块替换掉.</p></li><li><p>近期最少使用算法(LRU): 依据访问的局部性原理选择近期内长久未访问过的存储行作为替换的行, 平均命中率要比 FIFO 要高, 是堆栈类算法.</p><p>LRU 算法对每行设置一个计数器, Cache 命中一次, 命中行计数器清0,其他各行计数器加 1, 需要替换时比较各特定行的计数值, 将计数值最大的行换出.</p></li><li><p>最不经常使用算法(LFU): 将一段时间内访问次数最少的存储行换出. 每行也设置一个计数器, 新行建立后从 0 开始计数, 每访问一次, 被访问的计数器加 1,需要替换时比较计数值, 将计数值最小的行换出.</p></li></ol><h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><p>见上面的问题</p><p>主要搭配有两种:</p><ul><li>写回法搭配写分配法</li><li>全写法搭配非写分配法</li></ul><h2 id="3-7-虚拟存储器"><a href="#3-7-虚拟存储器" class="headerlink" title="3.7 虚拟存储器"></a>3.7 虚拟存储器</h2><p>结构: ==CPU - Cache - 主存 - 辅助存储器==</p><p>这样层次是硬件直接实现的, 对操作系统透明(看不见)</p><p><strong>虚拟存储器是一个逻辑模型. 功能: 用户给出一个地址, 叫做虚地址或逻辑地址, 虚拟存储器要给出该地址对应的数据</strong></p><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="页式虚拟存储器-重点"><a href="#页式虚拟存储器-重点" class="headerlink" title="页式虚拟存储器(重点)"></a>页式虚拟存储器(重点)</h4><p>虚拟空间与主存空间都被划分成同样大小的页, 主存的页称为实页, 虚存的页称为虚页.</p><h4 id="段式虚拟存储器"><a href="#段式虚拟存储器" class="headerlink" title="段式虚拟存储器"></a>段式虚拟存储器</h4><p>按程序的逻辑结构划分的, 各个段的长度因程序而异. 虚拟地址分为两部分: 段号和段内地址.</p><h3 id="虚实地址转换"><a href="#虚实地址转换" class="headerlink" title="虚实地址转换"></a>虚实地址转换</h3><ul><li>快表 TLB</li><li>慢表 Page</li></ul><h1 id="4-指令系统"><a href="#4-指令系统" class="headerlink" title="4 指令系统"></a>4 指令系统</h1><h2 id="4-1-指令格式"><a href="#4-1-指令格式" class="headerlink" title="4.1 指令格式"></a>4.1 指令格式</h2><p><strong>指令</strong>: 是指计算机执行某种操作的命令, 是计算机运行的最小功能单位.</p><p>一台计算机的所有指令的集合构成该机的指令系统, 也称为指令集.</p><p>一台计算机只能执行自己指令系统中的指令, 不能执行其他系统的指令.</p><p>一条指令通常包括<strong>操作码字段</strong>和<strong>地址字段</strong>两部分</p><h4 id="地址码"><a href="#地址码" class="headerlink" title="地址码"></a>地址码</h4><p>设指令字长及存储字长均为 32 位, 操作码占 8 位, 地址码占 24 位.</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211013105500470.png" alt="image-20211013105500470"></p><h4 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h4><p>有定长和扩展两种.</p><p>扩展操作码就是预留 全 1 作为标识, 使用地址字段作为操作码. 变换三地址指令二地址指令一地址指令等. 如果操作码字段读到 1110, 就将之后的作为地址码.</p><h4 id="操作类型"><a href="#操作类型" class="headerlink" title="操作类型"></a>操作类型</h4><ol><li>数据传送(LOAD,STORE)</li><li>算术逻辑操作</li><li>移位操作</li><li>转移操作</li><li>输入输出操作</li></ol><h2 id="4-2-寻址"><a href="#4-2-寻址" class="headerlink" title="4.2 寻址"></a>4.2 寻址</h2><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211014102053970.png" alt="image-20211014102053970"></p><h4 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h4><ol><li>指令寻址: 下一条与执行指令的指令地址: 始终由程序计数器 PC 给出</li><li>数据寻址: 确定本条指令的操作数地址</li></ol><h3 id="4-2-1-指令寻址"><a href="#4-2-1-指令寻址" class="headerlink" title="4.2.1 指令寻址"></a>4.2.1 指令寻址</h3><ul><li>顺序寻址: (PC) + 1 -&gt; PC</li><li>跳跃寻址: 由转移指令指出</li></ul><h3 id="4-2-2-数据寻址"><a href="#4-2-2-数据寻址" class="headerlink" title="4.2.2 数据寻址"></a>4.2.2 数据寻址</h3><h4 id="操作数类型"><a href="#操作数类型" class="headerlink" title="操作数类型"></a>操作数类型</h4><ul><li>地址: 无符号数</li><li>数字: 定点数, 浮点数, 十进制树(BCD 码)</li><li>字符: ASCII 码</li><li>逻辑树: 逻辑运算</li></ul><p>寻址特征有很多种, 例如直接寻址.不需要记</p><p><strong>直接寻址</strong>: 指令字中的形式地址 A 就是操作数的真实地址 EA, 即 EA=A. 优点: 简单</p><p><strong>间接寻址</strong>: 指令的地址字段给出的地址不是操作数的真实地址, 而是操作数有效地址存在的存储单元的地址. 也就是操作数地址的地址. 即 EA=(A). 优点: 可扩大寻址范围(EA 位数大于 A)</p><p><strong>寄存器寻址</strong>: 在指令字中直接给出操作数所在的寄存器编号. 优点: 执行阶段不访问主存, 执行速度快. 缺点: 昂贵.</p><p><strong>寄存器间接寻址</strong>: 寄存器中给出的不是一个操作数, 而是操作数所在主存 单元的地址. 特点: 与一般间接寻址快, 但指令执行阶段需要访问主存.</p><p><strong>隐含寻址</strong>: 不是明显给出操作数的地址,而是在指令中隐含着操作数的地址. 也就是直接指出操作数在 ACC 中.</p><h4 id="偏移寻址"><a href="#偏移寻址" class="headerlink" title="偏移寻址"></a>偏移寻址</h4><ul><li><strong>基址寻址</strong>: 将 CPU 中基址寄存器(BR) 的内容加上指令格式中的形式地址 A, 而形成操作数的有效地址, 即 EA=(BR)+A</li><li><strong>变址寻址</strong>: 有效地址 EA 等于指令字中的形式地址 A 与变址寄存器 IX 的内容相加之和, 即 EA=(IX)+A, 其中 IX 为变址寄存器(专用, 可以由用户改变), 也可使用通用寄存器作为变址寄存器.</li><li><strong>相对寻址</strong>: 把程序计数器 PC 的内容加上指令格式中的形式地址 A 而形成操作数的有效地址, 即 EA=(PC) + A, 其中 A 是相对于当前指令地址的位移量, 可正可负, 补码表示. 优点: 操作数的地址不是固定的, 随着 PC 变化而变化. 相对寻址广泛应用于转移指令.</li></ul><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211014114305246.png" alt="image-20211014114305246"></p><h4 id="堆栈寻址"><a href="#堆栈寻址" class="headerlink" title="堆栈寻址"></a>堆栈寻址</h4><p>操作数存放在对战中, 隐含使用堆栈指针(SP)作为操作数地址.</p><h2 id="4-3-CISC-和-RISC-替换版"><a href="#4-3-CISC-和-RISC-替换版" class="headerlink" title="4.3 CISC 和 RISC 替换版"></a>4.3 CISC 和 RISC 替换版</h2><ul><li>CISC<ul><li>Complex Instruction Set Computer</li><li>设计思路: 一条指令完成一个复杂的基本功能</li><li>代表: x86, 主要用于笔记本,台式机</li><li>80-20 规律: 典型程序中 80%的语句仅仅用处理机中 20%的指令</li></ul></li><li>RISC<ul><li>Reduced Instruction Set Computer</li><li>设计思路: 一条指令完成一个基本”动作”; 多条指令组合完成一个复杂的基本功能.</li><li>代表: ARM 架构, 主要用于手机,平板, 苹果刚换了 M1芯片</li></ul></li></ul><h1 id="5-中央处理器"><a href="#5-中央处理器" class="headerlink" title="5 中央处理器"></a>5 中央处理器</h1><h2 id="5-1-CPU-的功能和基本结构"><a href="#5-1-CPU-的功能和基本结构" class="headerlink" title="5.1 CPU 的功能和基本结构"></a>5.1 CPU 的功能和基本结构</h2><h4 id="CPU-的功能"><a href="#CPU-的功能" class="headerlink" title="CPU 的功能"></a>CPU 的功能</h4><h4 id=""><a href="#" class="headerlink" title=""></a><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211015104718363.png" alt="image-20211015104718363"></h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211015105015039.png" alt="image-20211015105015039"></p><h4 id="运算器的基本结构"><a href="#运算器的基本结构" class="headerlink" title="运算器的基本结构"></a>运算器的基本结构</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211015112352413.png" alt="image-20211015112352413"></p><h4 id="控制器的基本结构"><a href="#控制器的基本结构" class="headerlink" title="控制器的基本结构"></a>控制器的基本结构</h4><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211015112301827.png" alt="image-20211015112301827"></p><h4 id="CPU-的基本结构"><a href="#CPU-的基本结构" class="headerlink" title="CPU 的基本结构"></a>CPU 的基本结构</h4><p>将运算器和控制器两者结合就是 CPU 的基本结构. 主要分为四部分:</p><ul><li>ALU</li><li>寄存器</li><li>中断系统</li><li>CU</li></ul><p>简单了解就好!</p><h2 id="5-2-指令执行过程"><a href="#5-2-指令执行过程" class="headerlink" title="5.2 指令执行过程"></a>5.2 指令执行过程</h2><p>指令周期的概念: 一条指令执行分为不同的阶段</p><p>数据流: 不同阶段要求依次访问的数据序列</p><p>指令执行方案: 如何安排多条指令的执行?</p><h4 id="指令周期"><a href="#指令周期" class="headerlink" title="指令周期"></a>指令周期</h4><p>指令周期: CPU 从主存中每取出并执行一条指令所需的全部时间</p><p>指令周期 = 若干机器周期(CPU 周期)</p><p>机器周期 = 若干时钟周期(这是 CPU 操作的<strong>最基本单位</strong>)</p><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211015114348796.png" alt="image-20211015114348796"></p><p>每个指令周期内机器周期数可以不等, 每个机器周期内的节拍数也可以不等. (每个指令任务是不一样的)</p><h4 id="指令周期流程"><a href="#指令周期流程" class="headerlink" title="指令周期流程"></a>指令周期流程</h4><ol><li>取指周期: 取指令</li><li>间址周期: 取有效地址</li><li>执行周期: 取操作数</li><li>中断周期: 保存程序断点</li></ol><h4 id="指令执行方案"><a href="#指令执行方案" class="headerlink" title="指令执行方案"></a>指令执行方案</h4><ol><li>单指令周期</li><li>多指令周期</li><li>流水线方案</li></ol><h2 id="5-3-数据通路"><a href="#5-3-数据通路" class="headerlink" title="5.3 数据通路"></a>5.3 数据通路</h2><h3 id="5-3-1-数据通路—CPU-内部单总线模式"><a href="#5-3-1-数据通路—CPU-内部单总线模式" class="headerlink" title="5.3.1 数据通路—CPU 内部单总线模式"></a>5.3.1 数据通路—CPU 内部单总线模式</h3><p>![image-20211015192300654](/Users/yiqing/Library/Application Support/typora-user-images/image-20211015192300654.png)</p><h3 id="5-3-2-数据链路—专用数据通路方式"><a href="#5-3-2-数据链路—专用数据通路方式" class="headerlink" title="5.3.2 数据链路—专用数据通路方式"></a>5.3.2 数据链路—专用数据通路方式</h3><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211015204050146.png" alt="image-20211015204050146"></p><blockquote><p>总结: 数据通路都是魔法世界, 看不懂, 学不会</p></blockquote><h2 id="5-4-控制器的功能和工作原理"><a href="#5-4-控制器的功能和工作原理" class="headerlink" title="5.4 控制器的功能和工作原理"></a>5.4 控制器的功能和工作原理</h2><h3 id="5-4-1-硬布线"><a href="#5-4-1-硬布线" class="headerlink" title="5.4.1 硬布线"></a>5.4.1 硬布线</h3><p><strong>太难了, 略.</strong></p><h4 id="CPU-的控制方式"><a href="#CPU-的控制方式" class="headerlink" title="CPU 的控制方式"></a>CPU 的控制方式</h4><p>指: 产生不同微操作命令序列所用的时序控制方式.</p><ol><li><p>同步控制方式</p><p>整个系统所有的控制信号均来自一个统一的时钟信号.</p><p>控制电路简单, 运行速度慢</p></li><li><p>异步控制方式</p><p>异步控制方式不存在基准时标信号. 各部件按自身固有的速度工作, 通过应答方式进行联络.</p><p>运行速度快, 控制电路比较复杂</p></li><li><p>联合控制方式</p><p>对各种不同的指令的微操作实行大部分采用同步控制, 小部分采用异步控制的方法</p></li></ol><h3 id="5-4-2-微程序"><a href="#5-4-2-微程序" class="headerlink" title="5.4.2 微程序"></a>5.4.2 微程序</h3><p>事先把<strong>微操作控制信号</strong>存储在一个专门的存储器(控制存储器)中, 将每一条机器指令编写成一个微程序, 用寻址用户程序机器指令的办法来寻址每个微程序中的微指令</p><p><strong>太难了,详细略</strong></p><h2 id="5-5-指令流水线"><a href="#5-5-指令流水线" class="headerlink" title="5.5 指令流水线"></a>5.5 指令流水线</h2><h3 id="5-5-1-概念和性能指标"><a href="#5-5-1-概念和性能指标" class="headerlink" title="5.5.1 概念和性能指标"></a>5.5.1 概念和性能指标</h3><p><strong>指令流水线: 一条指令的执行过程可以分成多个阶段, 占用不同的资源, 就能使多条指令同时进行</strong></p><ul><li>取址: 根据 PC 内容访问主存, 取出一条指令送到 IR 中</li><li>分析: 对指令操作码进行译码, 按照给定的寻址方式和地址字段中的内容形成操作数的有效地址 EA, 并从有效地址 EA 中取出操作数.</li><li>执行: 根据操作码字段, 完成指令规定的功能, 即把运算结果写到通用寄存器或主存中.</li></ul><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211016141734053.png" alt="image-20211016141734053"></p><h4 id="流水线的性能指标"><a href="#流水线的性能指标" class="headerlink" title="流水线的性能指标"></a>流水线的性能指标</h4><ol><li>吞吐率: 单位时间内流水线所完成的任务数量.</li><li>加速比: 完成同样一批任务, 不使用流水线和使用流水线的时间之比</li><li>效率: 设备使用率</li></ol><h3 id="5-5-2-影响因素分类"><a href="#5-5-2-影响因素分类" class="headerlink" title="5.5.2 影响因素分类"></a>5.5.2 影响因素分类</h3><ol><li><p>结构相关(资源冲突)</p><p>由于多条指令在同一时刻征用同一资源所引起的冲突</p></li><li><p>数据相关(数据冲突)</p><p>数据相关指在一个程序中, 存在必须等前一条指令执行完之后才能执行后一条指令的情况</p></li><li><p>控制相关</p><p>当流水线遇到转移指令和其他改变 PC 值的指令而造成断流时, 会引起控制相关</p></li></ol><h1 id="6-总线"><a href="#6-总线" class="headerlink" title="6 总线"></a>6 总线</h1><blockquote><p>计组的记忆就像是一场梦</p></blockquote><h2 id="6-1-概念与分类"><a href="#6-1-概念与分类" class="headerlink" title="6.1 概念与分类"></a>6.1 概念与分类</h2><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>总线是一组能为多个部件==分时共享==的公共信息传送线路.</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>按数据传输格式<ul><li>串行总线</li><li>并行总线</li></ul></li><li>按总线的功能(连接的部件)<ul><li>片内总线<ul><li>芯片内部的总线</li></ul></li><li><strong>系统总线</strong><ul><li>数据总线</li><li>地址总线</li><li>控制总线</li></ul></li><li>通信总线</li></ul></li><li>按时序控制<ul><li>同步总线</li><li>异步总线</li></ul></li></ul><h4 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h4><p>传输周期, 时钟周期, 工作频率, 时钟频率, 总线宽度, 总线带宽, 总线复用, 信号线数</p><h2 id="6-2-总线仲裁"><a href="#6-2-总线仲裁" class="headerlink" title="6.2 总线仲裁"></a>6.2 总线仲裁</h2><p>如何解决多个设备争用总线的问题? (不是重点)</p><h2 id="6-3-总线操作和定时"><a href="#6-3-总线操作和定时" class="headerlink" title="6.3 总线操作和定时"></a>6.3 总线操作和定时</h2><p>占用总线的一对设备如何进行数据传输?</p><ul><li>同步定时方式(同步通信)</li><li>异步定时方式(异步通信)</li><li>半同步通信</li><li>分离式通信</li></ul><h2 id="6-4-总线标准"><a href="#6-4-总线标准" class="headerlink" title="6.4 总线标准"></a>6.4 总线标准</h2><p>易于实现系统的模块化设计</p><h1 id="7-I-O"><a href="#7-I-O" class="headerlink" title="7 I/O"></a>7 I/O</h1><h2 id="7-1-I-O-系统基本概念"><a href="#7-1-I-O-系统基本概念" class="headerlink" title="7.1 I/O 系统基本概念"></a>7.1 I/O 系统基本概念</h2><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211016174116909.png" alt="image-20211016174116909"></p><h2 id="7-2-外部设备"><a href="#7-2-外部设备" class="headerlink" title="7.2 外部设备"></a>7.2 外部设备</h2><h3 id="7-2-1-输入输出设备"><a href="#7-2-1-输入输出设备" class="headerlink" title="7.2.1 输入输出设备"></a>7.2.1 输入输出设备</h3><h3 id="7-2-2-外存储器"><a href="#7-2-2-外存储器" class="headerlink" title="7.2.2 外存储器"></a>7.2.2 外存储器</h3><p><strong>都不重要</strong></p><h2 id="7-3-I-O-接口"><a href="#7-3-I-O-接口" class="headerlink" title="7.3 I/O 接口"></a>7.3 I/O 接口</h2><p><strong>接口可以看作两个部件之间的交接部分</strong></p><p>I/O 接口是主机和外设之间的交接界面, 通过接口可以实现主机和外设之间的信息交换.</p><h4 id="接口的功能"><a href="#接口的功能" class="headerlink" title="接口的功能"></a>接口的功能</h4><ol><li>设备选址</li><li>传送命令</li><li>传送数据</li><li>反应 I/O 设备的工作状态</li></ol><h2 id="7-4-I-O-方式"><a href="#7-4-I-O-方式" class="headerlink" title="7.4 I/O 方式"></a>7.4 I/O 方式</h2><h3 id="7-4-1-程序查询方式"><a href="#7-4-1-程序查询方式" class="headerlink" title="7.4.1 程序查询方式"></a>7.4.1 程序查询方式</h3><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211018101010804.png" alt="image-20211018101010804"></p><p>主要特点是: 踏步; 串行.</p><h3 id="7-4-2-中断机制"><a href="#7-4-2-中断机制" class="headerlink" title="7.4.2 中断机制"></a>7.4.2 中断机制</h3><p>程序中断是指计算机执行现行程序的过程中, 出现某些急需处理的异常情况或特殊请求, CPU 暂时中止线性程序, 而转去对这些异常情况或特殊请求进行处理, 在处理完毕后 CPU 又自动返回到现行程序的断点处, 继续执行原程序.</p><p><strong>内容略</strong></p><h3 id="7-4-3-程序中断方式"><a href="#7-4-3-程序中断方式" class="headerlink" title="7.4.3 程序中断方式"></a>7.4.3 程序中断方式</h3><p><img src="/Users/yiqing/Documents/blogs/source/_posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20211018113733269.png" alt="image-20211018113733269"></p><h3 id="7-4-4-DMA-方式"><a href="#7-4-4-DMA-方式" class="headerlink" title="7.4.4 DMA 方式"></a>7.4.4 DMA 方式</h3><p>略</p><hr><blockquote><p>至此, 大概全部跟着走了一遍了, 有很多内容因为工作使用不到或者太难了就略过了. 毕竟我也不考研嘛.</p><p>继续努力! 年薪百万! </p><p>一清于 21 年 10 月 18 日</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机组成原理学习笔记&quot;&gt;&lt;a href=&quot;#计算机组成原理学习笔记&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理学习笔记&quot;&gt;&lt;/a&gt;计算机组成原理学习笔记&lt;/h1&gt;&lt;p&gt;最近发现自己离科班出身差了”挂科四大件”&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="笔记" scheme="http://yiiiqing.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="计算机组成原理" scheme="http://yiiiqing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-主从复制</title>
    <link href="http://yiiiqing.github.io/2021/09/10/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yiiiqing.github.io/2021/09/10/MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</id>
    <published>2021-09-10T05:48:51.000Z</published>
    <updated>2021-09-10T06:42:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-主从复制"><a href="#MySQL-主从复制" class="headerlink" title="MySQL 主从复制"></a>MySQL 主从复制</h1><p>以下是 linux 版本的搭建</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>以下来自另一篇 blog</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>slave 会从 master 读取 binlog 来进行数据同步</p><h4 id="三步骤"><a href="#三步骤" class="headerlink" title="三步骤"></a>三步骤</h4><ol><li>master 将该表记录到二进制日志 (binary log). 这些记录过程叫做二进制日志事件, binary log events;</li><li>slave 将 master 的 binary log events 拷贝到它的中继日志 (relay log);</li><li>slava 重做中继日志中的事件, 将改变应用到自己的数据库中. MySQL 复制是异步的且串行化的</li></ol><h3 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h3><ul><li>每个 slave 只有一个 master</li><li>每个 slave 只能有一个唯一的服务器 ID</li><li>每个 master 可以有多个 slave</li></ul><h3 id="最大问题"><a href="#最大问题" class="headerlink" title="最大问题"></a>最大问题</h3><p>延时</p><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>首先在 docker 中启动两个 MySQL 服务, 这里使用的是 5.7 版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yiqings-laptop:~ yiqing$ docker ps</span><br><span class="line">CONTAINER ID   IMAGE          COMMAND                  CREATED        STATUS         PORTS                                                            NAMES</span><br><span class="line">747fe7f90035   2c9028880e58   &quot;docker-entrypoint.s…&quot;   3 hours ago    Up 3 hours     3306/tcp, 33060/tcp, 0.0.0.0:3307-&gt;3307/tcp, :::3307-&gt;3307/tcp   mysql-slave</span><br><span class="line">7df9dd80af21   2c9028880e58   &quot;docker-entrypoint.s…&quot;   2 months ago   Up 6 minutes   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp             mysql</span><br></pre></td></tr></table></figure><h3 id="修改主库"><a href="#修改主库" class="headerlink" title="修改主库"></a>修改主库</h3><ol><li>首先进入主库, 修改 my.cnf 文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/mysql/my.cnf</span><br></pre></td></tr></table></figure><p>如果没有 vim 命令, 需要安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt-get update # 更新软件源列表</span><br><span class="line">apt-get -y install vim # 安装 vim</span><br></pre></td></tr></table></figure><ol start="2"><li>在 my.cnf 文件中添加</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">#开启log-bin二进制日志</span><br><span class="line">log-bin=/var/log/mysql/mysql-bin</span><br><span class="line">#配置唯一的服务器ID</span><br><span class="line">server-id=1</span><br><span class="line">#下面这两个不是必须要配置</span><br><span class="line">#主要是为了使用带事务的InnoDB进行复制设置时尽可能提高持久性和一致性</span><br><span class="line">innodb_flush_log_at_trx_commit = 1</span><br><span class="line">sync_binlog = 1</span><br></pre></td></tr></table></figure><ol start="3"><li>创建日志目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /var/log/mysql</span><br><span class="line">chown myslq:mysql /var/log/mysql</span><br></pre></td></tr></table></figure><ol start="4"><li>重启数据库查看配置,这里是直接重启 docker</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 7df9dd80af21</span><br></pre></td></tr></table></figure><p>如果是centos,直接重启服务<code>systemctl start mysql</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;server_id&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| server_id     | 1     |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;log_bin&#x27;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| log_bin       | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;%skip_networking%&#x27;; #skip_networking默认是OFF关闭状态，启用后主从将无法通信</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| Variable_name   | Value |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">| skip_networking | OFF   |</span><br><span class="line">+-----------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><ol start="5"><li><p>在主库上建立用于主从复制的账号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CREATE USER &#x27;replication&#x27;@&#x27;%&#x27;;</span><br><span class="line">mysql&gt; GRANT REPLICATION SLAVE ON *.* TO &#x27;replication&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure></li><li><p>查看主库的二进制日志的名字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">| mysql-bin.000001 |      801 |              |                  |                   |</span><br><span class="line">+------------------+----------+--------------+------------------+-------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>记住这里的 file 和 position</p></li><li><p>关闭防火墙</p><p>由于 docker 不是 centos, 所以我跳过这一步</p><p>如果有: <code>service iptables stop</code></p></li></ol><h3 id="修改从库"><a href="#修改从库" class="headerlink" title="修改从库"></a>修改从库</h3><ol><li><p>关闭防火墙(同上)</p></li><li><p>设置配置文件 my.cnf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br></pre></td></tr></table></figure></li><li><p>配置主从复制参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; CHANGE MASTER TO MASTER_HOST=&#x27;172.17.0.2&#x27;,</span><br><span class="line">MASTER_USER=&#x27;replication&#x27;,</span><br><span class="line">MASTER_PASSWORD=&#x27;123456&#x27;,</span><br><span class="line">MASTER_LOG_FILE=&#x27;mysql-bin.000001&#x27;,</span><br><span class="line">MASTER_LOG_POS=801;</span><br></pre></td></tr></table></figure><p>这里的 ip 写的是 docker 的容器的 ip</p><p>docker 容器的 ip 查看方法: <code>docker inspect &lt;container id&gt;</code></p></li><li><p>启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; start slave;</span><br></pre></td></tr></table></figure></li><li><p>查看 slave 状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show slave status\G; # \G 表示用 kv 键值对输出</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting for master to send event</span><br><span class="line">                  Master_Host: 172.17.0.2</span><br><span class="line">                  Master_User: replication</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 60</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 801</span><br><span class="line">               Relay_Log_File: 747fe7f90035-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes # 这个一定要为 yes</span><br><span class="line">            Slave_SQL_Running: Yes # 这个一定要为 yes</span><br></pre></td></tr></table></figure></li><li><p>如果有问题, 清理配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset slave all;</span><br></pre></td></tr></table></figure></li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol><li><p>在主库新增一个 test_rep 数据库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database test_rep;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>查看从库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">| test_rep           |</span><br><span class="line">+--------------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>可以看到从库也新增了一个 test_rep 数据库</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL-主从复制&quot;&gt;&lt;a href=&quot;#MySQL-主从复制&quot; class=&quot;headerlink&quot; title=&quot;MySQL 主从复制&quot;&gt;&lt;/a&gt;MySQL 主从复制&lt;/h1&gt;&lt;p&gt;以下是 linux 版本的搭建&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="MySQL" scheme="http://yiiiqing.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://yiiiqing.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL-关闭ONLY_FULL_GROUP_BY</title>
    <link href="http://yiiiqing.github.io/2021/09/06/MySQL-%E5%85%B3%E9%97%ADONLY-FULL-GROUP-BY/"/>
    <id>http://yiiiqing.github.io/2021/09/06/MySQL-%E5%85%B3%E9%97%ADONLY-FULL-GROUP-BY/</id>
    <published>2021-09-06T02:21:34.000Z</published>
    <updated>2021-09-06T02:27:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL关闭-ONLY-FULL-GROUP-BY"><a href="#MySQL关闭-ONLY-FULL-GROUP-BY" class="headerlink" title="MySQL关闭 ONLY_FULL_GROUP_BY"></a>MySQL关闭 ONLY_FULL_GROUP_BY</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>如果在 group by 的时候出现如下问题,可以通过关闭 MySQL 的参数来解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#x27;db0629.tbl_emp.id&#x27; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode=only_full_group_by</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>MySQL 5.7.5及以上功能依赖检测功能。默认情况下启用ONLY_FULL_GROUP_BY SQL模式，MySQL将拒绝选择列表，HAVING条件或ORDER BY列表的查询引用在GROUP BY子句中既未命名的非集合列，也不在功能上依赖于它们。（5.7.5之前，MySQL没有检测到功能依赖关系，默认情况下不启用ONLY_FULL_GROUP_BY。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="临时解决"><a href="#临时解决" class="headerlink" title="临时解决"></a>临时解决</h3><p>直接修改变量参数, 可以通过下面这个简单的脚本直接修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET SESSION sql_mode=(SELECT REPLACE(@@sql_mode,&#x27;ONLY_FULL_GROUP_BY,&#x27;,&#x27;&#x27;));</span><br></pre></td></tr></table></figure><h3 id="永久解决"><a href="#永久解决" class="headerlink" title="永久解决"></a>永久解决</h3><p>直接修改 MySQL 的配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">-sql_mode=ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br><span class="line">+sql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION</span><br></pre></td></tr></table></figure><p>然后重启 MySQL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>因为 <code>ONLY_FULL_GROUP_BY</code> 更加符合 SQL 标准，所以不建议关掉</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL关闭-ONLY-FULL-GROUP-BY&quot;&gt;&lt;a href=&quot;#MySQL关闭-ONLY-FULL-GROUP-BY&quot; class=&quot;headerlink&quot; title=&quot;MySQL关闭 ONLY_FULL_GROUP_BY&quot;&gt;&lt;/a&gt;MySQL关闭 </summary>
      
    
    
    
    <category term="MySQL" scheme="http://yiiiqing.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://yiiiqing.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>冒泡排序</title>
    <link href="http://yiiiqing.github.io/2021/08/16/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yiiiqing.github.io/2021/08/16/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</id>
    <published>2021-08-16T02:50:31.000Z</published>
    <updated>2021-08-16T05:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>最近重新学习算法, 发现这东西真的得时常复习, 或者一次彻底整会, 我选择后者</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>冒泡排序(Bubble Sort) 是一种交换排序, 它的基本思想是: 两两比较相邻记录的关键字, 如果反序则交换, 知道没有反序的记录为止.</strong> </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>冒泡法其实原理核心就是两两比较, 每一轮比较就得到一个极值.</p><p>两个数比较需要一次</p><p>三个数比较需要两次</p><p>得出: <strong>N 个数比较需要 N-1 次(这是外循环)</strong></p><p>又因为每次比较都会增长有序序列, 所以吧, 每次比较次数会变少一次, 每次比较次数取决于有序序列的长度. <strong>第 i 趟的排序次数为$(N-i)$次. (这是内循环)</strong></p><p>所以可以用嵌套循环, 外层控制循环次数, 内层控制每一次循环的比较次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;arr.length; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;arr.length-i; j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[j-<span class="number">1</span>] &gt; arr[j])</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>最好的情况, 只用走一次, 所以为$O(n)$</p><p>最坏的情况, 需要$n-1$次排序,每次$n-i$次比较, 每次比较移动三次, 不算移动开销的话</p><p>需要比较$1+2+3+…+(n-1)=\frac{n(n-1)}{2}$ 次.</p><p>计算移动开销就是$\frac{3n(n-1)}{2}$ 次</p><p>所以总的时间复杂度就是$O(n^2)$</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><ol><li><p>基本实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序的第一种实现, 没有任何优化</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bubbleSort1</span><span class="params">(<span class="type">int</span> [] a)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;<span class="comment">//表示n次排序过程。</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;n-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j-<span class="number">1</span>] &gt; a[j])&#123;<span class="comment">//前面的数字大于后面的数字就交换</span></span><br><span class="line">                <span class="comment">//交换a[j-1]和a[j]</span></span><br><span class="line">                <span class="type">int</span> temp;</span><br><span class="line">                temp = a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j];</span><br><span class="line">                a[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进一步优化</p><p>因为如果数组部分有序, 其实每次比较都不需要再排序了. 所以设置一个 flag, 如果这一趟发生交换, 则为 true, 否则为 false. </p><p>如果有一趟没有发生交换,则排序已经完成.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BubbleSort</span> <span class="keyword">implements</span> <span class="title class_">IArraySort</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] sourceArray) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 对 arr 进行拷贝，不改变参数内容</span></span><br><span class="line">        <span class="type">int</span>[] arr = Arrays.copyOf(sourceArray, sourceArray.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h1&gt;&lt;p&gt;最近重新学习算法, 发现这东西真的得时常复习, 或者一次彻底整会, 我选择后者&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="算法" scheme="http://yiiiqing.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="排序" scheme="http://yiiiqing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread.join方法</title>
    <link href="http://yiiiqing.github.io/2021/08/06/Java-Thread-join%E6%96%B9%E6%B3%95/"/>
    <id>http://yiiiqing.github.io/2021/08/06/Java-Thread-join%E6%96%B9%E6%B3%95/</id>
    <published>2021-08-06T03:19:33.000Z</published>
    <updated>2021-08-06T03:34:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thread-类的-join-方法"><a href="#Thread-类的-join-方法" class="headerlink" title="Thread 类的 join 方法"></a>Thread 类的 join 方法</h1><p>今天看到一个问题</p><p>如何确保 main 方法所在的线程是 Java 程序最后结束的线程</p><p>答案是使用 join 方法</p><p>于是去了解了一下这个方法</p><h2 id="join-的作用"><a href="#join-的作用" class="headerlink" title="join 的作用"></a>join 的作用</h2><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>跟刚才我看到的问题类似, 一个面试题:</p><blockquote><p>Java 中如何让多线程按照自己指定的顺序执行?</p></blockquote><p>最简单的回答就是通过 Thread.join 来实现</p><p>直接上代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinDemo</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  Thread previousThread; <span class="comment">//上一个线程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">JoinDemo</span><span class="params">(Thread previousThread, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.previousThread = previousThread;</span><br><span class="line">    <span class="built_in">this</span>.i = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//调用上一个线程的join方法</span></span><br><span class="line">      previousThread.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep((<span class="type">long</span>) Math.random() * <span class="number">10000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;num:&quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">previousThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      <span class="type">JoinDemo</span> <span class="variable">joinDemo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JoinDemo</span>(previousThread, i);</span><br><span class="line">      joinDemo.start();</span><br><span class="line">      previousThread = joinDemo;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中,每个线程会随机 sleep 一段时间, 如果将<code>previousThread.join()</code>注释掉,结束顺序将会随机</p><p>如果不注释,可以看到结果为 0 到 9 依次排列</p><p><strong>所以 join 对于线程的作用就是阻塞,等待线程中止后返回.</strong></p><p>注意阻塞这一点,如果线程一直不结束,将会一直阻塞</p><p><strong>注意: 必须在 start 之后调用 join 才有意义</strong></p><h2 id="join-原理"><a href="#join-原理" class="headerlink" title="join 原理"></a>join 原理</h2><p>看一下源码来理解一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">  <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">      <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">      <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      wait(delay);</span><br><span class="line">      now = System.currentTimeMillis() - base;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到, 核心是调用 wait 方法(Object 类的)</p><p>由于 wait 方法必须要获取锁, 所以 join 方法被 synchronized 修饰, 在方法层面, 相当于 synchroinzed(this), 是本身的实例</p><h3 id="线程执行完毕唤醒主线程的原因"><a href="#线程执行完毕唤醒主线程的原因" class="headerlink" title="线程执行完毕唤醒主线程的原因"></a>线程执行完毕唤醒主线程的原因</h3><p>对于线程来说, wait 方法阻塞之后需要 notify/notifyall 来唤醒.那么这个 join 最后是怎么唤醒主线程的? 是因为底层的源码在线程执行完毕后有一个唤醒操作</p><h2 id="join-的使用场景"><a href="#join-的使用场景" class="headerlink" title="join 的使用场景"></a>join 的使用场景</h2><p>适用于我们需要等待线程执行结果来进行后续处理的场合</p><p>参考资料:</p><ol><li><a href="https://zhuanlan.zhihu.com/p/53078651">https://zhuanlan.zhihu.com/p/53078651</a></li><li><a href="https://www.cnblogs.com/duanxz/p/5038471.html">https://www.cnblogs.com/duanxz/p/5038471.html</a></li><li><a href="https://www.journaldev.com/1024/java-thread-join-example">https://www.journaldev.com/1024/java-thread-join-example</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Thread-类的-join-方法&quot;&gt;&lt;a href=&quot;#Thread-类的-join-方法&quot; class=&quot;headerlink&quot; title=&quot;Thread 类的 join 方法&quot;&gt;&lt;/a&gt;Thread 类的 join 方法&lt;/h1&gt;&lt;p&gt;今天看到一个问题&lt;/</summary>
      
    
    
    
    <category term="Java" scheme="http://yiiiqing.github.io/categories/Java/"/>
    
    
    <category term="Thread" scheme="http://yiiiqing.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>.bash_profile更改不起效</title>
    <link href="http://yiiiqing.github.io/2021/07/22/bash-profile%E6%9B%B4%E6%94%B9%E4%B8%8D%E8%B5%B7%E6%95%88/"/>
    <id>http://yiiiqing.github.io/2021/07/22/bash-profile%E6%9B%B4%E6%94%B9%E4%B8%8D%E8%B5%B7%E6%95%88/</id>
    <published>2021-07-22T08:48:50.000Z</published>
    <updated>2021-07-22T08:51:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="bash-profile更改不起效"><a href="#bash-profile更改不起效" class="headerlink" title=".bash_profile更改不起效"></a>.bash_profile更改不起效</h1><p>问题</p><p>最近项目中需要修改环境变量,配置了之后发现即使</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>java 项目中<code>System.getenv()</code>都拿不到,</p><p>思前想后不知道什么原因</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>重启</p><p>…</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;bash-profile更改不起效&quot;&gt;&lt;a href=&quot;#bash-profile更改不起效&quot; class=&quot;headerlink&quot; title=&quot;.bash_profile更改不起效&quot;&gt;&lt;/a&gt;.bash_profile更改不起效&lt;/h1&gt;&lt;p&gt;问题&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Linux" scheme="http://yiiiqing.github.io/categories/Linux/"/>
    
    
    <category term="配置" scheme="http://yiiiqing.github.io/tags/%E9%85%8D%E7%BD%AE/"/>
    
    <category term="bash" scheme="http://yiiiqing.github.io/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性-Stream</title>
    <link href="http://yiiiqing.github.io/2021/07/19/Java8%E6%96%B0%E7%89%B9%E6%80%A7-Stream/"/>
    <id>http://yiiiqing.github.io/2021/07/19/Java8%E6%96%B0%E7%89%B9%E6%80%A7-Stream/</id>
    <published>2021-07-19T02:54:58.000Z</published>
    <updated>2021-07-19T10:07:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><p>最近疯狂补习 Java8 的特性, 今天学习了一下 Stream.</p><p>基本上是跟着廖雪峰官网的教程来学习的, 自己边看别写,将 Stream 整理了一下</p><p>原文链接: <a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889">https://www.liaoxuefeng.com/wiki/1252599548343744/1322402873081889</a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Java8 引入了 Lambda 表达式,还引入了流式 API: Stream API</p><p>位于 java.util.stream 包</p><p>特点:</p><ul><li>提供了一套新的流式处理的抽象序列</li><li>支持函数式变成和链式操作</li><li>可以表示无限序列,并且大多数情况下是惰性求值的<ul><li>元素可能全部存储在内存,也有可能需要实时计算</li><li>惰性计算: 真正的计算通常发生在最后的结果的获取</li></ul></li></ul><h2 id="创建-Stream"><a href="#创建-Stream" class="headerlink" title="创建 Stream"></a>创建 Stream</h2><p>多种方法</p><h3 id="Stream-of"><a href="#Stream-of" class="headerlink" title="Stream.of()"></a>Stream.of()</h3><p>是一个静态方法, 传入可变参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>);</span><br><span class="line">stream.forEach(System.out.println);</span><br></pre></td></tr></table></figure><p>方便测试</p><h3 id="基于数组或-Collection"><a href="#基于数组或-Collection" class="headerlink" title="基于数组或 Collection"></a>基于数组或 Collection</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream1 = Arrays.stream(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>&#125;);</span><br><span class="line">Stream&lt;String&gt; stream2 = List.of(<span class="string">&quot;X&quot;</span>,<span class="string">&quot;Y&quot;</span>,<span class="string">&quot;Z&quot;</span>).stream();</span><br><span class="line">stream1.forEach(System.out.println);</span><br><span class="line">stream2.forEach(System.out.println);</span><br></pre></td></tr></table></figure><p>对于 <code>Collection(List, Set, Queue...)</code>, 直接调用 <code>stream()</code>方法就可以获得 <code>Stream</code></p><h3 id="基于-Supplier"><a href="#基于-Supplier" class="headerlink" title="基于 Supplier"></a>基于 Supplier</h3><p>还可以通过<code>Stream.generate()</code>方法, 需要传入一个<code>Supplier</code>对象</p><p><code>Stream&lt;String&gt; s = Stream.generate(Supplier&lt;String&gt;sp);</code></p><p>基于<code>Supplier</code>创建的<code>Stream</code>会不断调用<code>Supplier.get()</code>方法来不断产生下一个元素, 这种<code>Stream</code>保存的不是元素, 而是算法, 可以用来表示无限序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StreamTest</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Stream&lt;Integer&gt; natural = Stream.generate(<span class="keyword">new</span> <span class="title class_">NatualSupplier</span>());</span><br><span class="line">    natural.limit(<span class="number">20</span>).forEach(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NatualSupplier</span> <span class="keyword">implements</span> <span class="title class_">Supplier</span>&lt;Integer&gt;&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Integer <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 <code>Supplier&lt;Integer&gt;</code> 模拟了一个无限序列, 如果用 List 表示,即便在 int 范围内,也会占用很大内存, 而<code>Stream</code>几乎不占用空间,因为每个元素都是实时计算出来的,用的时候再算</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><p>通过一些 API 提供的接口</p><h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>因为 Java 的<strong>泛型不支持基本类型</strong></p><p>为了避免繁复的装箱拆箱,Java 提供了 IntStream, LongStream, DoubleStream 这三种使用基本类型的 Stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntStream</span> <span class="variable">is</span> <span class="operator">=</span> Arrays.stream(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line"><span class="type">LongStream</span> <span class="variable">ls</span> <span class="operator">=</span> List.of(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span>).stream().mapToLong(Long::parseLong);</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>利用 Stream 实现输出斐波那契序列:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="title class_">long</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, a -&gt; <span class="keyword">new</span> <span class="title class_">long</span>[]&#123;a[<span class="number">1</span>], a[<span class="number">0</span>] + a[<span class="number">1</span>]&#125;)</span><br><span class="line">  .limit(<span class="number">100</span>)</span><br><span class="line">  .map(a -&gt; a[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span>)</span><br><span class="line">  .forEach(System.err::print);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fi2</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">IntSupplier</span> <span class="variable">is</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IntSupplier</span>() &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAsInt</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> pre;</span><br><span class="line">      <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> pre+current;</span><br><span class="line">      pre = current;</span><br><span class="line">      current = next;</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  IntStream.generate(is).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fibonacci1</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">//  生成 整形数组，在通过flatmap 转换成一个集合输出</span></span><br><span class="line">  Stream.iterate(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, t -&gt; <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;t[<span class="number">0</span>] + t[<span class="number">1</span>], t[<span class="number">0</span>] + t[<span class="number">1</span>] + t[<span class="number">1</span>]&#125;) <span class="comment">// 1</span></span><br><span class="line">    .flatMap(Arrays::stream) <span class="comment">// flatMap 数据， 将数组元素转化成stream //2</span></span><br><span class="line">    .limit(<span class="number">10</span>) <span class="comment">// 默认是无线长度，所以要给出限制</span></span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h2><p>操作分为两类:</p><ul><li>转换操作: 把一个 Stream 转换为另一个 Stream; <strong>不会触发任何计算</strong></li><li>聚合操作: 对 Stream 的每个元素进行计算,得到一个确定的结果; <strong>立刻计算</strong></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>Stream.map()</code>是<code>Stream</code>最常用的一个转换方法，它把一个<code>Stream</code>转换为另一个<code>Stream</code>。</p><p>所谓<code>map</code>操作，就是把一种操作运算，映射到一个序列的每一个元素上。</p><p><code>map()</code>方法接收一个<code>Function</code>接口对象, 其定义了一个<code>apply()</code>方法, 将 T 类型转换为 R 类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List.of(<span class="string">&quot;  Apple &quot;</span>, <span class="string">&quot; pear &quot;</span>, <span class="string">&quot; ORANGE&quot;</span>, <span class="string">&quot; BaNaNa &quot;</span>)</span><br><span class="line">                .stream()</span><br><span class="line">                .map(String::trim) <span class="comment">// 去空格</span></span><br><span class="line">                .map(String::toLowerCase) <span class="comment">// 变小写</span></span><br><span class="line">                .forEach(System.out::println); <span class="comment">// 打印</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>所谓<code>filter()</code>操作，就是对一个<code>Stream</code>的所有元素一一进行测试，不满足条件的就被“滤掉”了，剩下的满足条件的元素就构成了一个新的<code>Stream</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">  .filter(n -&gt; n % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">  .forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p><code>map()</code>和<code>filter()</code>都是<code>Stream</code>的转换方法，而<code>Stream.reduce()</code>则是<code>Stream</code>的一个聚合方法，它可以把一个<code>Stream</code>的所有元素按照聚合函数聚合成一个结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>).reduce(<span class="number">0</span>, (acc, n) -&gt; acc + n);</span><br><span class="line">System.out.println(sum); <span class="comment">// 47</span></span><br></pre></td></tr></table></figure><p>reduce 是聚合方法,聚合方法会<strong>立刻对 Stream 进行计算</strong></p><h3 id="输出为-List"><a href="#输出为-List" class="headerlink" title="输出为 List"></a>输出为 List</h3><p>把 Stream 转换为 List 也是一个聚合操作,它会强制 Stream 输出每个元素</p><p>方法是调用<code>collect()</code>并传入<code>Collectors.toList()</code>对象</p><p>它实际上是一个<code>Collector</code>实例，通过类似<code>reduce()</code>的操作，把每个元素添加到一个收集器中（实际上是<code>ArrayList</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;Pear&quot;</span>, <span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">List&lt;String&gt; collect = stream.filter(s -&gt; s != <span class="literal">null</span> &amp;&amp; !s.isEmpty())</span><br><span class="line">  .collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br></pre></td></tr></table></figure><p>类似的，<code>collect(Collectors.toSet())</code>可以把<code>Stream</code>的每个元素收集到<code>Set</code>中。</p><h3 id="输出为数组"><a href="#输出为数组" class="headerlink" title="输出为数组"></a>输出为数组</h3><p>把Stream的元素输出为数组和输出为List类似，我们只需要调用<code>toArray()</code>方法，并传入数组的“构造方法”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;);</span><br><span class="line">String[] array = list.stream().toArray(String[]::new);</span><br></pre></td></tr></table></figure><p>注意到传入的“构造方法”是<code>String[]::new</code>，它的签名实际上是<code>IntFunction&lt;String[]&gt;</code>定义的<code>String[] apply(int)</code>，即传入<code>int</code>参数，获得<code>String[]</code>数组的返回值。</p><h3 id="输出为Map"><a href="#输出为Map" class="headerlink" title="输出为Map"></a>输出为Map</h3><p>如果我们要把Stream的元素收集到Map中，就稍微麻烦一点。因为对于每个元素，添加到Map时需要key和value，因此，我们要指定两个映射函数，分别把元素映射为key和value：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;APPL:Apple&quot;</span>, <span class="string">&quot;MSFT:Microsoft&quot;</span>);</span><br><span class="line">        Map&lt;String, String&gt; map = stream</span><br><span class="line">                .collect(Collectors.toMap(</span><br><span class="line">                        <span class="comment">// 把元素s映射为key:</span></span><br><span class="line">                        s -&gt; s.substring(<span class="number">0</span>, s.indexOf(<span class="string">&#x27;:&#x27;</span>)),</span><br><span class="line">                        <span class="comment">// 把元素s映射为value:</span></span><br><span class="line">                        s -&gt; s.substring(s.indexOf(<span class="string">&#x27;:&#x27;</span>) + <span class="number">1</span>)));</span><br><span class="line">        System.out.println(map);</span><br></pre></td></tr></table></figure><h3 id="分组输出"><a href="#分组输出" class="headerlink" title="分组输出"></a>分组输出</h3><p>使用<code>Collectors.groupingBy()</code></p><p>提供两个函数,一个是分组的key，这里使用<code>s -&gt; s.substring(0, 1)</code>，表示只要首字母相同的<code>String</code>分到一组，第二个是分组的value，这里直接使用<code>Collectors.toList()</code>，表示输出为<code>List</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Blackberry&quot;</span>, <span class="string">&quot;Coconut&quot;</span>, <span class="string">&quot;Avocado&quot;</span>, <span class="string">&quot;Cherry&quot;</span>, <span class="string">&quot;Apricots&quot;</span>);</span><br><span class="line">Map&lt;String, java.util.List&lt;String&gt;&gt; groups = list.stream()</span><br><span class="line">  .collect(Collectors.groupingBy(</span><br><span class="line">    s -&gt; s.substring(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    Collectors.toList()</span><br><span class="line">  ));</span><br><span class="line">System.out.println(groups);</span><br></pre></td></tr></table></figure><p>运行结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    A=[Apple, Avocado, Apricots],</span><br><span class="line">    B=[Banana, Blackberry],</span><br><span class="line">    C=[Coconut, Cherry]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>按照对象的某一个字段分组</p><p>现有对象 Student 为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">  <span class="type">int</span> gradeId; <span class="comment">// 年级</span></span><br><span class="line">  <span class="type">int</span> classId; <span class="comment">// 班级</span></span><br><span class="line">  String name; <span class="comment">// 名字</span></span><br><span class="line">  <span class="type">int</span> score; <span class="comment">// 分数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照 gradeId 分组:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Student&gt; studentStream = Stream.of(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;A&quot;</span>, <span class="number">80</span>),</span><br><span class="line">                                          <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;B&quot;</span>, <span class="number">90</span>),</span><br><span class="line">                                          <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;C&quot;</span>, <span class="number">100</span>),</span><br><span class="line">                                          <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="string">&quot;D&quot;</span>, <span class="number">90</span>),</span><br><span class="line">                                          <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">2</span>, <span class="string">&quot;E&quot;</span>, <span class="number">100</span>),</span><br><span class="line">                                          <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&quot;F&quot;</span>, <span class="number">80</span>),</span><br><span class="line">                                          <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="string">&quot;G&quot;</span>, <span class="number">100</span>),</span><br><span class="line">                                          <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="string">&quot;H&quot;</span>, <span class="number">80</span>),</span><br><span class="line">                                          <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="string">&quot;I&quot;</span>, <span class="number">90</span>));</span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; map = studentStream.collect(</span><br><span class="line">  Collectors.groupingBy(</span><br><span class="line">    s -&gt; s.gradeId,</span><br><span class="line">    Collectors.toList()</span><br><span class="line">  )</span><br><span class="line">);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure><p>输出结果为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=[Student(gradeId=<span class="number">1</span>, classId=<span class="number">1</span>, name=A, score=<span class="number">80</span>), Student(gradeId=<span class="number">1</span>, classId=<span class="number">2</span>, name=B, score=<span class="number">90</span>), Student(gradeId=<span class="number">1</span>, classId=<span class="number">3</span>, name=C, score=<span class="number">100</span>)], <span class="number">2</span>=[Student(gradeId=<span class="number">2</span>, classId=<span class="number">1</span>, name=D, score=<span class="number">90</span>), Student(gradeId=<span class="number">2</span>, classId=<span class="number">2</span>, name=E, score=<span class="number">100</span>), Student(gradeId=<span class="number">2</span>, classId=<span class="number">3</span>, name=F, score=<span class="number">80</span>)], <span class="number">3</span>=[Student(gradeId=<span class="number">3</span>, classId=<span class="number">1</span>, name=G, score=<span class="number">100</span>), Student(gradeId=<span class="number">3</span>, classId=<span class="number">2</span>, name=H, score=<span class="number">80</span>), Student(gradeId=<span class="number">3</span>, classId=<span class="number">3</span>, name=I, score=<span class="number">90</span>)]&#125;</span><br></pre></td></tr></table></figure><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = List.of(<span class="string">&quot;Orange&quot;</span>, <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>)</span><br><span class="line">            .stream()</span><br><span class="line">            .sorted()</span><br><span class="line">            .collect(Collectors.toList());</span><br></pre></td></tr></table></figure><h3 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;D&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .distinct()</span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [A, B, C, D]</span></span><br></pre></td></tr></table></figure><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>)</span><br><span class="line">    .stream()</span><br><span class="line">    .skip(<span class="number">2</span>) <span class="comment">// 跳过A, B</span></span><br><span class="line">    .limit(<span class="number">3</span>) <span class="comment">// 截取C, D, E</span></span><br><span class="line">    .collect(Collectors.toList()); <span class="comment">// [C, D, E]</span></span><br></pre></td></tr></table></figure><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s1 = List.of(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>).stream();</span><br><span class="line">Stream&lt;String&gt; s2 = List.of(<span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>).stream();</span><br><span class="line"><span class="comment">// 合并:</span></span><br><span class="line">Stream&lt;String&gt; s = Stream.concat(s1, s2);</span><br><span class="line">System.out.println(s.collect(Collectors.toList())); <span class="comment">// [A, B, C, D, E]</span></span><br></pre></td></tr></table></figure><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>是把 Stream 的每个元素映射为 Stream,然后合并成一个新的 Stream</p><p>如果<code>Stream</code>的元素是集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt; s = Stream.of(</span><br><span class="line">        Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),</span><br><span class="line">        Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">        Arrays.asList(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>));</span><br></pre></td></tr></table></figure><p>而我们希望把上述<code>Stream</code>转换为<code>Stream&lt;Integer&gt;</code>，就可以使用<code>flatMap()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; i = s.flatMap(list -&gt; list.stream());</span><br></pre></td></tr></table></figure><h3 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h3><p>通常情况下，对<code>Stream</code>的元素进行处理是单线程的，即一个一个元素进行处理。但是很多时候，我们希望可以并行处理<code>Stream</code>的元素，因为在元素数量非常大的情况，并行处理可以大大加快处理速度。</p><p>把一个普通<code>Stream</code>转换为可以并行处理的<code>Stream</code>非常简单，只需要用<code>parallel()</code>进行转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">String[] result = s.parallel() <span class="comment">// 变成一个可以并行处理的Stream</span></span><br><span class="line">                   .sorted() <span class="comment">// 可以进行并行排序</span></span><br><span class="line">                   .toArray(String[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure><p>经过<code>parallel()</code>转换后的<code>Stream</code>只要可能，就会对后续操作进行并行处理。我们不需要编写任何多线程代码就可以享受到并行处理带来的执行效率的提升。</p><h3 id="其他聚合方法"><a href="#其他聚合方法" class="headerlink" title="其他聚合方法"></a>其他聚合方法</h3><p>除了<code>reduce()</code>和<code>collect()</code>外，<code>Stream</code>还有一些常用的聚合方法：</p><ul><li><code>count()</code>：用于返回元素个数；</li><li><code>max(Comparator&lt;? super T&gt; cp)</code>：找出最大元素；</li><li><code>min(Comparator&lt;? super T&gt; cp)</code>：找出最小元素。</li></ul><p>针对<code>IntStream</code>、<code>LongStream</code>和<code>DoubleStream</code>，还额外提供了以下聚合方法：</p><ul><li><code>sum()</code>：对所有元素求和；</li><li><code>average()</code>：对所有元素求平均数。</li></ul><p>还有一些方法，用来测试<code>Stream</code>的元素是否满足以下条件：</p><ul><li><code>boolean allMatch(Predicate&lt;? super T&gt;)</code>：测试是否所有元素均满足测试条件；</li><li><code>boolean anyMatch(Predicate&lt;? super T&gt;)</code>：测试是否至少有一个元素满足测试条件。</li></ul><p>最后一个常用的方法是<code>forEach()</code>，它可以循环处理<code>Stream</code>的每个元素，我们经常传入<code>System.out::println</code>来打印<code>Stream</code>的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; s = ...</span><br><span class="line">s.forEach(str -&gt; &#123;</span><br><span class="line">    System.out.println(&quot;Hello, &quot; + str);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>Stream</code>提供的常用操作有：</p><p>转换操作：<code>map()</code>，<code>filter()</code>，<code>sorted()</code>，<code>distinct()</code>；</p><p>合并操作：<code>concat()</code>，<code>flatMap()</code>；</p><p>并行处理：<code>parallel()</code>；</p><p>聚合操作：<code>reduce()</code>，<code>collect()</code>，<code>count()</code>，<code>max()</code>，<code>min()</code>，<code>sum()</code>，<code>average()</code>；</p><p>其他操作：<code>allMatch()</code>, <code>anyMatch()</code>, <code>forEach()</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Stream&quot;&gt;&lt;a href=&quot;#Stream&quot; class=&quot;headerlink&quot; title=&quot;Stream&quot;&gt;&lt;/a&gt;Stream&lt;/h1&gt;&lt;p&gt;最近疯狂补习 Java8 的特性, 今天学习了一下 Stream.&lt;/p&gt;
&lt;p&gt;基本上是跟着廖雪峰官网的教</summary>
      
    
    
    
    <category term="Java" scheme="http://yiiiqing.github.io/categories/Java/"/>
    
    
    <category term="Java8" scheme="http://yiiiqing.github.io/tags/Java8/"/>
    
  </entry>
  
</feed>
